// Simple scalable test for computation of Owicki-Gries annotation for Petri Net of a server-client interaction with a choice between different requests
// -----------------------------------------------------------------------------------------------------------------------------------------------------

//@ variables (req Int) (res Int) (x Int)

//@ semantics [0] {req,res,x} (and (= req 0) (= res 0) (= x 0))
//@ semantics [1] {req} (= req 1)
//@ semantics [2] {req} (= req 2)
//@ semantics [3] { } (> req 0)
//@ semantics [4] { } (= req 1)
//@ semantics [5] { } (= req 2)
//@ semantics [6] {res,x} (and (= x (- 5)) (= res 1))
//@ semantics [7] {res,x} (and (= x 5) (= res 1))
//@ semantics [8] { } (= res 1)
//@ semantics [9] { } (>= x 0)
//@ semantics [10] { } (<= x 0)

PetriNet program = (
  alphabet    = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" "[6]" "[7]" "[8]" "[9]" "[10]" },
  places      = { "m" "s.l0" "s.l1" "s.l2" "s.l3" "s.l4" "s.l5" "c.l0" "c.l1" "c.l2" "c.l3" "c.l4" "e1" "e2" },
  transitions = {
    ({ "m" } "[0]" { "s.l0" "c.l0" })
    ({ "s.l0" } "[3]" { "s.l1" })
    ({ "s.l1" } "[4]" { "s.l2" })
    ({ "s.l1" } "[5]" { "s.l3" })
    ({ "s.l2" } "[6]" { "s.l4" })
    ({ "s.l3" } "[7]" { "s.l5" })
    ({ "c.l0" } "[1]" { "c.l1" })
    ({ "c.l0" } "[2]" { "c.l2" })
    ({ "c.l1" } "[8]" { "c.l3" })
    ({ "c.l2" } "[8]" { "c.l4" })
    ({ "c.l3" } "[9]" { "e1" })
    ({ "c.l4" } "[10]" { "e2" })
  },
  initialMarking = { "m" },
  acceptingPlaces = { "e1" "e2" }
);

FiniteAutomaton proof1 = (
     alphabet      = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" "[6]" "[7]" "[8]" "[9]" "[10]" },
     states        = { "true" "(and (= req 0) (= res 0))" "(and (= req 1) (= res 0))" "(and (= req 1) (< x 0) (= res 1))" "false" },
     initialStates = { "true" },
     finalStates   = { "false" },
     transitions   = {
       ("true" "[0]" "(and (= req 0) (= res 0))")
       ("(and (= req 0) (= res 0))" "[1]" "(and (= req 1) (= res 0))")
       ("(and (= req 0) (= res 0))" "[3]" "false")
       ("(and (= req 0) (= res 0))" "[4]" "false")
       ("(and (= req 0) (= res 0))" "[5]" "false")
       ("(and (= req 0) (= res 0))" "[8]" "false")
       ("(and (= req 1) (= res 0))" "[3]" "(and (= req 1) (= res 0))")
       ("(and (= req 1) (= res 0))" "[4]" "(and (= req 1) (= res 0))")
       ("(and (= req 1) (= res 0))" "[5]" "false")
       ("(and (= req 1) (= res 0))" "[6]" "(and (= req 1) (< x 0) (= res 1))")
       ("(and (= req 1) (= res 0))" "[8]" "false")
       ("(and (= req 1) (< x 0) (= res 1))" "[8]" "(and (= req 1) (< x 0) (= res 1))")
       ("(and (= req 1) (< x 0) (= res 1))" "[9]" "false")
       ("false" "[0]" "false")
       ("false" "[1]" "false")
       ("false" "[2]" "false")
       ("false" "[3]" "false")
       ("false" "[4]" "false")
       ("false" "[5]" "false")
       ("false" "[6]" "false")
       ("false" "[7]" "false")
       ("false" "[8]" "false")
       ("false" "[9]" "false")
       ("false" "[10]" "false")
     }
);

FiniteAutomaton proof2 = (
     alphabet      = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" "[6]" "[7]" "[8]" "[9]" "[10]" },
     states        = { "true" "(and (= req 0) (= res 0))" "(and (= req 2) (= res 0))" "(and (= req 2) (> x 0) (= res 1))" "false" },
     initialStates = { "true" },
     finalStates   = { "false" },
     transitions   = {
       ("true" "[0]" "(and (= req 0) (= res 0))")
       ("(and (= req 0) (= res 0))" "[2]" "(and (= req 2) (= res 0))")
       ("(and (= req 0) (= res 0))" "[3]" "false")
       ("(and (= req 0) (= res 0))" "[4]" "false")
       ("(and (= req 0) (= res 0))" "[5]" "false")
       ("(and (= req 0) (= res 0))" "[8]" "false")
       ("(and (= req 2) (= res 0))" "[3]" "(and (= req 2) (= res 0))")
       ("(and (= req 2) (= res 0))" "[4]" "false")
       ("(and (= req 2) (= res 0))" "[5]" "(and (= req 2) (= res 0))")
       ("(and (= req 2) (= res 0))" "[7]" "(and (= req 2) (> x 0) (= res 1))")
       ("(and (= req 2) (= res 0))" "[8]" "false")
       ("(and (= req 2) (> x 0) (= res 1))" "[8]" "(and (= req 2) (> x 0) (= res 1))")
       ("(and (= req 2) (> x 0) (= res 1))" "[10]" "false")
       ("false" "[0]" "false")
       ("false" "[1]" "false")
       ("false" "[2]" "false")
       ("false" "[3]" "false")
       ("false" "[4]" "false")
       ("false" "[5]" "false")
       ("false" "[6]" "false")
       ("false" "[7]" "false")
       ("false" "[8]" "false")
       ("false" "[9]" "false")
       ("false" "[10]" "false")
     }
);


