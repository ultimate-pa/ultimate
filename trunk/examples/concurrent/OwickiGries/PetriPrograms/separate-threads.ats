// Simple test for computation of Owicki-Gries annotation
// ------------------------------------------------------

//@ variables (y Int) (x Int) (z1 Int) (z2 Int)

//@ semantics [0] {x} (= x 1)
//@ semantics [1] {y} (= y 1)
//@ semantics [2] {z1,z2} (and (= z1 x) (= z2 y))
//@ semantics [3] {z1} (= z1 (+ |old(z1)| 1))
//@ semantics [4] {z1} (= z1 (* |old(z1)| 2))
//@ semantics [5] {  } (< z1 4)
//@ semantics [6] {z2} (= z2 (+ |old(z2)| 1))
//@ semantics [7] {z2} (= z2 (* |old(z2)| 2))
//@ semantics [8] {  } (< z2 4)

PetriNet program = (
  alphabet    = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" "[6]" "[7]" "[8]" },
  places      = { "main.l0" "main.l1" "main.l2" "t1.l1" "t1.l2" "t1.l3" "t1.e" "t2.l1" "t2.l2" "t2.l3" "t2.e" },
  transitions = {
    ({ "main.l0" } "[0]" { "main.l1" })
    ({ "main.l1" } "[1]" { "main.l2" })
    ({ "main.l2" } "[2]" { "t1.l1" "t2.l1" })
    ({ "t1.l1" } "[3]" { "t1.l2" })
    ({ "t1.l2" } "[4]" { "t1.l3" })
    ({ "t1.l3" } "[5]" { "t1.e"  })
    ({ "t2.l1" } "[6]" { "t2.l2" })
    ({ "t2.l2" } "[7]" { "t2.l3" })
    ({ "t2.l3" } "[8]" { "t2.e"  })
  },
  initialMarking = { "main.l0" },
  acceptingPlaces = { "t1.e" "t2.e" }
);

FiniteAutomaton proof1 = (
     alphabet      = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" "[6]" "[7]" "[8]" },
     states        = { "true" "(= x 1)" "(= z1 1)" "(= z1 2)" "(= z1 4)" "false" },
     initialStates = { "true" },
     finalStates   = { "false" },
     transitions   = {
       ("true"    "[0]" "(= x 1)")

       ("(= x 1)" "[1]" "(= x 1)")
       ("(= x 1)" "[6]" "(= x 1)")
       ("(= x 1)" "[7]" "(= x 1)")
       ("(= x 1)" "[8]" "(= x 1)")       
       ("(= x 1)" "[2]" "(= z1 1)")

       ("(= z1 1)" "[1]" "(= z1 1)")
       ("(= z1 1)" "[6]" "(= z1 1)")
       ("(= z1 1)" "[7]" "(= z1 1)")
       ("(= z1 1)" "[8]" "(= z1 1)")
       ("(= z1 1)" "[3]" "(= z1 2)")

       ("(= z1 2)" "[1]" "(= z1 2)")
       ("(= z1 2)" "[6]" "(= z1 2)")
       ("(= z1 2)" "[7]" "(= z1 2)")
       ("(= z1 2)" "[8]" "(= z1 2)")
       ("(= z1 2)" "[4]" "(= z1 4)")

       ("(= z1 4)" "[1]" "(= z1 4)")
       ("(= z1 4)" "[6]" "(= z1 4)")
       ("(= z1 4)" "[7]" "(= z1 4)")
       ("(= z1 4)" "[8]" "(= z1 4)")
       ("(= z1 4)" "[5]" "false")

       ("false" "[1]" "false")
       ("false" "[6]" "false")
       ("false" "[7]" "false")
       ("false" "[8]" "false")
     }
);

FiniteAutomaton proof2 = (
     alphabet      = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" "[6]" "[7]" "[8]" },
     states        = { "true" "(= y 1)" "(= z2 1)" "(= z2 2)" "(= z2 4)" "false" },
     initialStates = { "true" },
     finalStates   = { "false" },
     transitions   = {
       ("true"    "[1]" "(= y 1)")

       ("(= y 1)" "[0]" "(= y 1)")
       ("(= y 1)" "[3]" "(= y 1)")
       ("(= y 1)" "[4]" "(= y 1)")
       ("(= y 1)" "[5]" "(= y 1)")       
       ("(= y 1)" "[2]" "(= z2 1)")

       ("(= z2 1)" "[0]" "(= z2 1)")
       ("(= z2 1)" "[3]" "(= z2 1)")
       ("(= z2 1)" "[4]" "(= z2 1)")
       ("(= z2 1)" "[5]" "(= z2 1)")
       ("(= z2 1)" "[6]" "(= z2 2)")

       ("(= z2 2)" "[0]" "(= z2 2)")
       ("(= z2 2)" "[3]" "(= z2 2)")
       ("(= z2 2)" "[4]" "(= z2 2)")
       ("(= z2 2)" "[5]" "(= z2 2)")
       ("(= z2 2)" "[7]" "(= z2 4)")

       ("(= z2 4)" "[0]" "(= z2 4)")
       ("(= z2 4)" "[3]" "(= z2 4)")
       ("(= z2 4)" "[4]" "(= z2 4)")
       ("(= z2 4)" "[5]" "(= z2 4)")
       ("(= z2 4)" "[8]" "false")

       ("false" "[0]" "false")
       ("false" "[6]" "false")
       ("false" "[7]" "false")
       ("false" "[8]" "false")
     }
);


