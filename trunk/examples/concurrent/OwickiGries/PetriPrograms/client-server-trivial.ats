// Simple scalable test for computation of Owicki-Gries annotation for Petri Net of a trivial server-client interaction
// --------------------------------------------------------------------------------------------------------------------

//@ variables (req Int) (res Int)

//@ semantics [0] {req,res} (and (= req 0) (= res 0))
//@ semantics [1] {req} (= req 1)
//@ semantics [2] { } (= req 1)
//@ semantics [3] {res} (= res 1)
//@ semantics [4] { } (= res 1)
//@ semantics [5] { } (or (distinct req 1) (distinct res 1))

PetriNet program = (
  alphabet    = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" },
  places      = { "m" "s.l0" "s.l1" "s.l2" "c.l0" "c.l1" "c.l2" "e" },
  transitions = {
    ({ "m" } "[0]" { "s.l0" "c.l0" })
    ({ "s.l0" } "[2]" { "s.l1" })
    ({ "s.l1" } "[3]" { "s.l2" })
    ({ "c.l0" } "[1]" { "c.l1" })
    ({ "c.l1" } "[4]" { "c.l2" })
    ({ "c.l2" } "[5]" { "e" })
  },
  initialMarking = { "m" },
  acceptingPlaces = { "e" }
);

FiniteAutomaton proof = (
     alphabet      = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]"},
     states        = { "true" "(and (= req 0) (= res 0))" "(and (= req 1) (= res 0))" "(and (= req 1) (= res 1))" "false" },
     initialStates = { "true" },
     finalStates   = { "false" },
     transitions   = {
       ("true" "[0]" "(and (= req 0) (= res 0))")
       ("(and (= req 0) (= res 0))" "[1]" "(and (= req 1) (= res 0))")
       ("(and (= req 0) (= res 0))" "[2]" "false")
       ("(and (= req 1) (= res 0))" "[3]" "(and (= req 1) (= res 1))")
       ("(and (= req 1) (= res 0))" "[2]" "(and (= req 1) (= res 0))")
       ("(and (= req 1) (= res 0))" "[4]" "false")
       ("(and (= req 1) (= res 1))" "[4]" "(and (= req 1) (= res 1))")
       ("(and (= req 1) (= res 1))" "[5]" "false")
     }
);



