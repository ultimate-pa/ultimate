// Simple scalable test for computation of Owicki-Gries annotation for Petri Net with a simple data race
// -----------------------------------------------------------------------------------------------------

//@ variables (x Int) (s Int) (c Int)

//@ semantics [0] {x,s} (and (= x 0) (= s 0) (= c 0))
//@ semantics [1] {s} (and (= |old(s)| 0) (= s 1))
//@ semantics [2] {s} (and (= s 0) (= c 0))
//@ semantics [3] {x} (= x (+ |old(x)| 1))
//@ semantics [4] { } (> c 1)
//@ semantics [5] {c} (= c 0)
//@ semantics [6] {c} (= c (+ |old(c)| 1))

PetriNet program = (
  alphabet    = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" "[6]" },
  places      = { "m" "t1.l0" "t1.l1" "t1.l2" "t1.l3" "t1.l4" "t2.l0" "t2.l1" "t2.l2" "t2.l3" "t2.l4" "e1" "e2" },
  transitions = {
    ({ "m" } "[0]" { "t1.l0" "t2.l0" })
    ({ "t1.l0" } "[1]" { "t1.l1" })
    ({ "t1.l1" } "[6]" { "t1.l2" })
    ({ "t1.l2" } "[3]" { "t1.l3" })
    ({ "t1.l2" } "[4]" { "e1" })
    ({ "t1.l3" } "[2]" { "t1.l4" })
    ({ "t2.l0" } "[1]" { "t2.l1" })
    ({ "t2.l1" } "[6]" { "t2.l2" })
    ({ "t2.l2" } "[3]" { "t2.l3" })
    ({ "t2.l2" } "[4]" { "e2" })
    ({ "t2.l3" } "[2]" { "t2.l4" })
  },
  initialMarking = { "m" },
  acceptingPlaces = { "e1" "e2" }
);

FiniteAutomaton proof = (
     alphabet      = { "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" "[6]" },
     states        = { "true" "(and (= c 0) (= s 0))" "(and (= c 0) (= s 1))" "(and (= c 1) (= s 1))" "false" },
     initialStates = { "true" },
     finalStates   = { "false" },
     transitions   = {
       ("true" "[0]" "(and (= c 0) (= s 0))")
       ("(and (= c 0) (= s 0))" "[1]" "(and (= c 0) (= s 1))")
       ("(and (= c 0) (= s 1))" "[6]" "(and (= c 1) (= s 1))")
       ("(and (= c 0) (= s 1))" "[1]" "false")
       ("(and (= c 1) (= s 1))" "[2]" "(and (= c 0) (= s 0))")
       ("(and (= c 1) (= s 1))" "[3]" "(and (= c 1) (= s 1))")
       ("(and (= c 1) (= s 1))" "[4]" "false")
       ("(and (= c 1) (= s 1))" "[1]" "false")
     }
);



