procedure nav01Example() {
	var x1,x1_new,x1_old : real;
	var x2,x2_new,x2_old : real;
	var v1,v1_new,v1_old : real;
	var v2,v2_new,v2_old : real;
	var t,t_new,t_old : real;
	var eps : real;
	
	// initial state
	assume ( 2.0000 <= x1 && x1 <= 3.0000 );
	assume ( 1.0000 <= x2 && x2 <= 2.0000 );
	assume ( 0.0 - 0.3000 <= v1 && v1 <= 0.3000 );
	assume ( 0.0 - 0.3000 <= v2 && v2 <= 0.0000 );
	assume (t == 0.0);
	assume (eps == 0.0);
	
	goto loc_5;
	
loc_0:
		x1_old := x1;
		x2_old := x2;
		v1_old := v1;
		v2_old := v2;
		t_old := t;
		
		// invariant
		assume (x1_old >= 0.0 - eps && x1_old <= 1.0 + eps);
		assume (x2_old >= 0.0 - eps && x2_old <= 1.0 + eps);
		
		havoc x1_new;
		havoc x2_new;
		havoc v1_new;
		havoc v2_new;
		havoc t_new;
		
		// flow
		assume ( 572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old == 0.0 &&
			572000048000001.0 * x1_new + 480000020000000.0 * v1_new + 40000000000000.0 * v2_new - 572000048000001.0 * x1_old - 480000020000000.0 * v1_old - 40000000000000.0 * v2_old - 572000048000001.0 * t_new == 0.0 &&
			572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 480000020000000.0 * v2_old <= 572000048000001.0 &&
			x2_new <= 1.0 &&
			232000019200000400000000000000.0 * v1_new + 38400001600000000000000000000.0 * v2_new - 232000019200000400000000000000.0 * v1_old - 38400001600000000000000000000.0 * v2_old - 690976100312005332000122000001.0 * t_new <= 0.0 &&
			38400001600000000000000000000.0 * v1_new + 232000019200000400000000000000.0 * v2_new - 38400001600000000000000000000.0 * v1_old - 232000019200000400000000000000.0 * v2_old - 439296067752003932000102000001.0 * t_new <= 0.0 &&
			9600000400000000000000.0 * v1_new + 800000000000000000000.0 * v2_new - 9600000400000000000000.0 * v1_old - 800000000000000000000.0 * v2_old - 29744003068000100000001.0 * t_new <= 0.0 &&
			800000000000000000000.0 * v1_new + 9600000400000000000000.0 * v2_new - 800000000000000000000.0 * v1_old - 9600000400000000000000.0 * v2_old - 19448002204000082000001.0 * t_new <= 0.0 &&
			480000020000000.0 * v1_new + 40000000000000.0 * v2_new - 572000048000001.0 * x1_old - 480000020000000.0 * v1_old - 40000000000000.0 * v2_old - 572000048000001.0 * t_new <= 0.0 &&
			x1_old <= 1.0 &&
			10.0 * v1_old <= 3.0 &&
			v2_old <= 0.0 &&
			t_new <= 1.0 &&
			10.0 * v2_old >= 0.0 - 3.0 &&
			10.0 * v1_old >= 0.0 - 3.0 &&
			x1_old >= 0.0 &&
			480000020000000.0 * v1_new + 40000000000000.0 * v2_new - 572000048000001.0 * x1_old - 480000020000000.0 * v1_old - 40000000000000.0 * v2_old - 572000048000001.0 * t_new >= 0.0-572000048000001.0 &&
			800000000000000000000.0 * v1_new + 9600000400000000000000.0 * v2_new - 800000000000000000000.0 * v1_old - 9600000400000000000000.0 * v2_old + 14872001820000074000001.0 * t_new >= 0.0 &&
			4800000200000000000000.0 * v1_new + 400000000000000000000.0 * v2_new - 4800000200000000000000.0 * v1_old - 400000000000000000000.0 * v2_old + 10296001436000066000001.0 * t_new >= 0.0 &&
			38400001600000000000000000000.0 * v1_new + 232000019200000400000000000000.0 * v2_new - 38400001600000000000000000000.0 * v1_old - 232000019200000400000000000000.0 * v2_old + 311168053568003420000096000001.0 * t_new >= 0.0 &&
			116000009600000200000000000000.0 * v1_new + 19200000800000000000000000000.0 * v2_new - 116000009600000200000000000000.0 * v1_old - 19200000800000000000000000000.0 * v2_old + 231088042844002944000089000001.0 * t_new >= 0.0 &&
			x2_new >= 0.0 &&
			572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 480000020000000.0 * v2_old >= 0.0 );
		
		// invariant
		assume (x1_new >= 0.0 - eps && x1_new <= 1.0 + eps);
		assume (x2_new >= 0.0 - eps && x2_new <= 1.0 + eps);
		
		x1 := x1_new;
		x2 := x2_new;
		v1 := v1_new;
		v2 := v2_new;
		t := t_new;
		
		// transitions
		if (*) {
			// assignment
			t := 0.0;
			goto loc_0;
		} else if (*) {
			// guard
			assume (x1 >= 1.0 - eps && v1 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_1;
		} else if (*) {
			// guard
			assume (x2 >= 1.0 - eps && v2 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_3;
		} else {
			goto end;
		}
		
loc_1:
		x1_old := x1;
		x2_old := x2;
		v1_old := v1;
		v2_old := v2;
		t_old := t;
		
		// invariant
		assume (x1_old >= 1.0 - eps && x1_old <= 2.0 + eps);
		assume (x2_old >= 0.0 - eps && x2_old <= 1.0 + eps);
		
		havoc x1_new;
		havoc x2_new;
		havoc v1_new;
		havoc v2_new;
		havoc t_new;
		
		// flow
		assume ( 572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old == 0.0 && 
			2000000.0 * x1_new - 24000001.0 * x2_new - 20000000.0 * v2_new - 2000000.0 * x1_old + 24000001.0 * x2_old + 20000000.0 * v2_old - 2000000.0 * t_new == 0.0 && 
			2900000240000005.0 * x2_new + 2400000100000000.0 * v2_new - 2900000240000005.0 * x2_old - 2400000100000000.0 * v2_old - 404000041000001.0 * t_new <= 0.0 && 
			960000040000000.0 * x2_new + 400000000000000.0 * v2_new - 960000040000000.0 * x2_old - 400000000000000.0 * v2_old - 544000048000001.0 * t_new <= 0.0 && 
			572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old <= 12000000000000.0 && 
			120000005.0 * x2_new + 100000000.0 * v2_new - 120000005.0 * x2_old - 100000000.0 * v2_old - 18000001.0 * t_new <= 0.0 && 
			24000001.0 * x2_new + 20000000.0 * v2_new + 2000000.0 * x1_old - 24000001.0 * x2_old - 20000000.0 * v2_old + 2000000.0 * t_new <= 4000000.0 && 
			20000000.0 * x2_new - 20000000.0 * x2_old - 26000001.0 * t_new <= 0.0 && 
			x2_new <= 1.0 && 
			x1_old <= 2.0 && 
			x2_old <= 1.0 && 
			v2_old <= 0.0 && 
			t_new <= 1.0 && 
			10.0 * v2_old >= 0.0 - 3.0 && 
			x2_old >= 0.0 && 
			x1_old >= 1.0 && 
			x2_new >= 0.0 && 
			20000000.0 * x2_new - 20000000.0 * x2_old + 34000001.0 * t_new >= 0.0 && 
			24000001.0 * x2_new + 20000000.0 * v2_new + 2000000.0 * x1_old - 24000001.0 * x2_old - 20000000.0 * v2_old + 2000000.0 * t_new >= 2000000.0 && 
			240000010.0 * x2_new + 200000000.0 * v2_new - 240000010.0 * x2_old - 200000000.0 * v2_old + 52000001.0 * t_new >= 0.0 && 
			572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old >= 0.0-12000000000000.0 && 
			960000040000000.0 * x2_new + 400000000000000.0 * v2_new - 960000040000000.0 * x2_old - 400000000000000.0 * v2_old + 768000054000001.0 * t_new >= 0.0 && 
			5800000480000010.0 * x2_new + 4800000200000000.0 * v2_new - 5800000480000010.0 * x2_old - 4800000200000000.0 * v2_old + 1208000074000001.0 * t_new >= 0.0 );
		
		// invariant
		assume (x1_new >= 1.0 - eps && x1_new <= 2.0 + eps);
		assume (x2_new >= 0.0 - eps && x2_new <= 1.0 + eps);
		
		x1 := x1_new;
		x2 := x2_new;
		v1 := v1_new;
		v2 := v2_new;
		t := t_new;
		
		// transitions
		if (*) {
			// assignment
			t := 0.0;
			goto loc_1;
		} else if (*) {
			// guard
			assume (x1 <= 1.0 + eps && v1 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_0;
		} else if (*) {
			// guard
			assume (x1 >= 2.0 - eps && v1 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_2;
		} else if (*) {
			// guard
			assume (x2 >= 1.0 - eps && v2 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_4;
		} else {
			goto end;
		}
		
loc_2:
		x1_old := x1;
		x2_old := x2;
		v1_old := v1;
		v2_old := v2;
		t_old := t;
		
		// invariant
		assume (x1_old >= 2.0 - eps && x1_old <= 3.0 + eps);
		assume (x2_old >= 0.0 - eps && x2_old <= 1.0 + eps);
		
		havoc x1_new;
		havoc x2_new;
		havoc v1_new;
		havoc v2_new;
		havoc t_new;
		
		//flow
		assume ( v2_new - v2_old == 0.0 && 
					v1_new - v1_old == 0.0 && 
					x2_new - x2_old == 0.0 && 
					x1_new - x1_old == 0.0 && 
					10.0 * v1_new <= 3.0 && 
					x1_old <= 3.0 && 
					x2_old <= 1.0 && 
					v2_old <= 0.0 && 
					t_new <= 1.0 && 
					t_new >= 0.0 && 
					10.0 * v2_old >= 0.0 - 3.0 && 
					x2_old >= 0.0 && 
					x1_old >= 2.0 && 
					10.0 * v1_new >= 0.0 - 3.0);
		
		// invariant
		assume (x1_new >= 2.0 - eps && x1_new <= 3.0 + eps);
		assume (x2_new >= 0.0 - eps && x2_new <= 1.0 + eps);
				
		x1 := x1_new;
		x2 := x2_new;
		v1 := v1_new;
		v2 := v2_new;
		t := t_new;
		
		// transitions
		if (*) {
			// assignment
			t := 0.0;
			goto loc_2;
		} else {
			goto end;
		}
		
loc_3:
		x1_old := x1;
		x2_old := x2;
		v1_old := v1;
		v2_old := v2;
		t_old := t;
		
		// invariant
		assume (x1_old >= 0.0 - eps && x1_old <= 1.0 + eps);
		assume (x2_old >= 1.0 - eps && x2_old <= 2.0 + eps);
		
		havoc x1_new;
		havoc x2_new;
		havoc v1_new;
		havoc v2_new;
		havoc t_new;
		
		// flow
		assume ( 572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old + 572000048000001.0 * t_new == 0.0 && 
			24000001.0 * x1_new - 2000000.0 * x2_new + 20000000.0 * v1_new - 24000001.0 * x1_old - 20000000.0 * v1_old + 2000000.0 * x2_old - 2000000.0 * t_new == 0.0 && 
			11600000960000020000000.0 * x2_new - 800000000000000000000.0 * v1_new + 800000000000000000000.0 * v1_old - 11600000960000020000000.0 * x2_old - 13936001736000072000001.0 * t_new <= 0.0 && 
			80000000000000.0 * x2_new - 400000000000000.0 * v1_new + 400000000000000.0 * v1_old - 80000000000000.0 * x2_old - 676000054000001.0 * t_new <= 0.0 && 
			40000000000000.0 * x2_new - 400000000000000.0 * v1_new + 400000000000000.0 * v1_old - 40000000000000.0 * x2_old - 776000058000001.0 * t_new <= 0.0 && 
			20000000.0 * x2 - 20000000.0 * x2_old - 26000001.0 * t_new <= 0.0&& 
			2000000.0 * x2 - 20000000.0 * v1 + 24000001.0 * x1_old + 20000000.0 * v1_old - 2000000.0 * x2_old + 2000000.0 * t_new <= 24000001.0 && 
			x2_new <= 2.0 && 
			x1_old <= 1.0 && 
			10.0 * v1_old <= 3.0 && 
			x2_old <= 2.0 && 
			v2_old <= 0.0 && 
			t_new <= 1.0 && 
			10.0 * v2_old >= 0.0 - 3.0 && 
			x2_old >= 1.0 && 
			10.0 * v1_old >= 0.0 - 3.0 && 
			x1_old >= 0.0 && 
			x2_new >= 1.0 && 
			2000000.0 * x2_new - 20000000.0 * v1_new + 24000001.0 * x1_old + 20000000.0 * v1_old - 2000000.0 * x2_old + 2000000.0 * t_new >= 0.0 && 
			10000000.0 * x2_new - 10000000.0 * x2_old + 28000001.0 * t_new >= 0.0 && 
			40000000000000.0 * x2_new - 400000000000000.0 * v1_new + 400000000000000.0 * v1_old - 40000000000000.0 * x2_old + 808000056000001.0 * t_new >= 0.0 && 
			80000000000000.0 * x2_new - 400000000000000.0 * v1_new + 400000000000000.0 * v1_old - 80000000000000.0 * x2_old + 768000054000001.0 * t_new >= 0.0 && 
			5800000480000010000000.0 * x2_new - 400000000000000000000.0 * v1_new + 400000000000000000000.0 * v1_old - 5800000480000010000000.0 * x2_old + 15640001874000075000001.0 * t_new >= 0.0);
		
		// invariant
		assume (x1_new >= 0.0 - eps && x1_new <= 1.0 + eps);
		assume (x2_new >= 1.0 - eps && x2_new <= 2.0 + eps);
				
		x1 := x1_new;
		x2 := x2_new;
		v1 := v1_new;
		v2 := v2_new;
		t := t_new;
		
		// transitions
		if (*) {
			// assignment
			t := 0.0;
			goto loc_3;
		} else if (*) {
			// guard
			assume (x2 <= 1.0 + eps && v2 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_0;
		} else if (*) {
			// guard
			assume (x1 >= 1.0 - eps && v1 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_4;
		} else if (*) {
			// guard
			assume (x2 >= 2.0 - eps && v2 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_6;
		} else {
			goto end;
		}

loc_4:
		x1_old := x1;
		x2_old := x2;
		v1_old := v1;
		v2_old := v2;
		t_old := t;
		
		// invariant
		assume (x1_old >= 1.0 - eps && x1_old <= 2.0 + eps);
		assume (x2_old >= 1.0 - eps && x2_old <= 2.0 + eps);
		
		havoc x1_new;
		havoc x2_new;
		havoc v1_new;
		havoc v2_new;
		havoc t_new;
		
		// flow
		assume ( 28600002400000050000000.0 * x2_new + 2000000000000000000000.0 * v1_new + 24000001000000000000000.0 * v2_new - 2000000000000000000000.0 * v1_old - 28600002400000050000000.0 * x2_old - 24000001000000000000000.0 * v2_old + 20223255605056307355339.0 * t_new == 0.0  && 
				100000000000000.0 * x1_new - 1200000050000000.0 * x2_new - 1000000000000000.0 * v2_new - 100000000000000.0 * x1_old + 1200000050000000.0 * x2_old + 1000000000000000.0 * v2_old - 919238849355339.0 * t_new == 0.0  && 
				100000000000000.0 * x1_new - 1200000050000000.0 * x2_new - 1000000000000000.0 * v2_new + 1200000050000000.0 * x2_old + 1000000000000000.0 * v2_old - 919238849355339.0 * t_new <= 200000000000000.0  && 
				x1_new <= 2.0  && 
				290000024000000500000000.0 * x2_new + 240000010000000000000000.0 * v2_new - 290000024000000500000000.0 * x2_old - 240000010000000000000000.0 * v2_old + 164594074732613496198051.0 * t_new <= 0.0  && 
				28600002400000050000000.0 * x2_new + 2000000000000000000000.0 * v1_new + 24000001000000000000000.0 * v2_new - 28600002400000050000000.0 * x2_old - 24000001000000000000000.0 * v2_old + 20223255605056307355339.0 * t_new <= 600000000000000000000.0  && 
				12000000500000000.0 * x2_new + 10000000000000000.0 * v2_new - 12000000500000000.0 * x2_old - 10000000000000000.0 * v2_old + 6673149594198051.0 * t_new <= 0.0  && 
				4800000200000000.0 * x2_new + 2000000000000000.0 * v2_new - 4800000200000000.0 * x2_old - 2000000000000000.0 * v2_old - 1081522541289327.0 * t_new <= 0.0  && 
				1300000050000000.0 * x2_new + 1000000000000000.0 * v2_new - 1300000050000000.0 * x2_old - 1000000000000000.0 * v2_old + 669238839355339.0 * t_new <= 0.0  && 
				20000000.0 * x2_new - 20000000.0 * x2_old - 26000001.0 * t_new <= 0.0  && 
				x2_new <= 2.0  && 
				x2_old <= 2.0  && 
				v2_old <= 0.0  && 
				t_new <= 1.0  && 
				10.0 * v2_old >= 0.0 - 3.0  && 
				x2_old >= 1.0  && 
				x2_new >= 1.0  && 
				1000000000000000.0 * x2_new - 1000000000000000.0 * x2_old + 2519238899355339.0 * t_new >= 0.0  && 
				1200000050000000.0 * x2_new + 1000000000000000.0 * v2_new - 1200000050000000.0 * x2_old - 1000000000000000.0 * v2_old + 1079238854355339.0 * t_new >= 0.0  && 
				1300000050000000.0 * x2_new + 1000000000000000.0 * v2_new - 1300000050000000.0 * x2_old - 1000000000000000.0 * v2_old + 1199238859355339.0 * t_new >= 0.0  && 
				28600002400000050000000.0 * x2_new + 2000000000000000000000.0 * v1_new + 24000001000000000000000.0 * v2_new - 28600002400000050000000.0 * x2_old - 24000001000000000000000.0 * v2_old + 20223255605056307355339.0 * t_new >= 0.0 - 600000000000000000000.0  && 
				29000002400000050000000.0 * x2_new + 24000001000000000000000.0 * v2_new - 29000002400000050000000.0 * x2_old - 24000001000000000000000.0 * v2_old + 25701733573766990355339.0 * t_new >= 0.0  && 
				48000002000000000000000.0 * x2_new + 20000000000000000000000.0 * v2_new - 48000002000000000000000.0 * x2_old - 20000000000000000000000.0 * v2_old + 75008035292163137355339.0 * t_new >= 0.0  && 
				x1_new >= 1.0  && 
				100000000000000.0 * x1_new - 1200000050000000.0 * x2_new - 1000000000000000.0 * v2_new + 1200000050000000.0 * x2_old + 1000000000000000.0 * v2_old - 919238849355339.0 * t_new >= 100000000000000.0 );
		
		// invariant
		assume (x1_new >= 1.0 - eps && x1_new <= 2.0 + eps);
		assume (x2_new >= 1.0 - eps && x2_new <= 2.0 + eps);
		
		x1 := x1_new;
		x2 := x2_new;
		v1 := v1_new;
		v2 := v2_new;
		t := t_new;
		
		// transitions
		if (*) {
			// assignment
			t := 0.0;
			goto loc_4;
		} else if (*) {
			// guard
			assume (x2 <= 1.0 + eps && v2 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_1;
		} else if (*) {
			// guard
			assume (x1 <= 1.0 + eps && v1 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_3;
		} else if (*) {
			// guard
			assume (x1 >= 2.0 - eps && v1 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_5;
		} else if (*) {
			// guard
			assume (x2 >= 2.0 - eps && v2 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_7;
		} else {
			goto end;
		}

loc_5:
		x1_old := x1;
		x2_old := x2;
		v1_old := v1;
		v2_old := v2;
		t_old := t;
		
		// invariant
		assume (x1_old >= 2.0 - eps && x1_old <= 3.0 + eps);
		assume (x2_old >= 1.0 - eps && x2_old <= 2.0 + eps);
		
		havoc x1_new;
		havoc x2_new;
		havoc v1_new;
		havoc v2_new;
		havoc t_new;
		
		// flow
		assume ( 572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old + 572000048000001.0 * t_new == 0.0 && 
				572000048000001.0 * x1_new + 480000020000000.0 * v1_new + 40000000000000.0 * v2_new - 572000048000001.0 * x1_old - 480000020000000.0 * v1_old - 40000000000000.0 * v2_old == 0.0 && 
				232000019200000400000000000000.0 * v1_new + 38400001600000000000000000000.0 * v2_new - 232000019200000400000000000000.0 * v1_old - 38400001600000000000000000000.0 * v2_old - 393536063912003852000102000001.0 * t_new <= 0.0 && 
				19200000800000000000000000000.0 * v1_new + 116000009600000200000000000000.0 * v2_new - 19200000800000000000000000000.0 * v1_old - 116000009600000200000000000000.0 * v2_old - 234520043132002950000089000001.0 * t_new <= 0.0 && 
				9600000400000000000000.0 * v1_new + 800000000000000000000.0 * v2_new - 9600000400000000000000.0 * v1_old - 800000000000000000000.0 * v2_old - 18304002108000080000001.0 * t_new <= 0.0 && 
				400000000000000000000.0 * v1_new + 4800000200000000000000.0 * v2_new - 400000000000000000000.0 * v1_old - 4800000200000000000000.0 * v2_old - 10296001436000066000001.0 * t_new <= 0.0 && 
				480000020000000.0 * v1_new + 40000000000000.0 * v2_new - 572000048000001.0 * x1_old - 480000020000000.0 * v1_old - 40000000000000.0 * v2_old <= 0.0 - 1144000096000002.0 && 
				40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old + 572000048000001.0 * t_new <=  0.0 - 572000048000001.0 && 
				x1_old <= 3.0 && 
				10.0 * v1_old <= 3.0 && 
				x2_old <= 2.0 && 
				v2_old <= 0.0 && 
				t_new <= 1.0 && 
				10.0 * v2_old >= 0.0 - 3.0 && 
				x2_old >= 1.0 && 
				10.0 * v1_old >= 0.0 - 3.0 && 
				x1_old >= 2.0 && 
				40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old + 572000048000001.0 * t_new >= 0.0 - 1144000096000002.0 && 
				480000020000000.0 * v1_new + 40000000000000.0 * v2_new - 572000048000001.0 * x1_old - 480000020000000.0 * v1_old - 40000000000000.0 * v2_old >= 0.0 - 1716000144000003.0 && 
				800000000000000000000.0 * v1_new + 9600000400000000000000.0 * v2_new - 800000000000000000000.0 * v1_old - 9600000400000000000000.0 * v2_old + 26312002780000094000001.0 * t_new >= 0.0 && 
				9600000400000000000000.0 * v1_new + 800000000000000000000.0 * v2_new - 9600000400000000000000.0 * v1_old - 800000000000000000000.0 * v2_old + 19448002204000082000001.0 * t_new >= 0.0 && 
				38400001600000000000000000000.0 * v1_new + 232000019200000400000000000000.0 * v2_new - 38400001600000000000000000000.0 * v1_old - 232000019200000400000000000000.0 * v2_old + 608608089968004900000116000001.0 * t_new >= 0.0 && 
				232000019200000400000000000000.0 * v1_new + 38400001600000000000000000000.0 * v2_new - 232000019200000400000000000000.0 * v1_old - 38400001600000000000000000000.0 * v2_old + 432432067176003920000102000001.0 * t_new >= 0.0 );
		
		// invariant
		assume (x1_new >= 2.0 - eps && x1_new <= 3.0 + eps);
		assume (x2_new >= 1.0 - eps && x2_new <= 2.0 + eps);
		
		x1 := x1_new;
		x2 := x2_new;
		v1 := v1_new;
		v2 := v2_new;
		t := t_new;
		
		// transitions
		if (*) {
			// assignment
			t := 0.0;
			goto loc_5;
		} else if (*) {
			// guard
			assume (x2 <= 1.0 + eps && v2 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_2;
		} else if (*) {
			// guard
			assume (x1 <= 2.0 + eps && v1 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_4;
		} else if (*) {
			// guard
			assume (x2 >= 2.0 - eps && v2 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_8;
		} else {
			goto end;
		}

loc_6:
		x1_old := x1;
		x2_old := x2;
		v1_old := v1;
		v2_old := v2;
		t_old := t;
		
		// invariant
		assume (x1_old >= 0.0 - eps && x1_old <= 1.0 + eps);
		assume (x2_old >= 2.0 - eps && x2_old <= 3.0 + eps);
		
		havoc x1_new;
		havoc x2_new;
		havoc v1_new;
		havoc v2_new;
		havoc t_new;
		
		// flow
		assume ( v2_new - v2_old == 0.0 && 
				v1_new - v1_old == 0.0 && 
				x2_new - x2_old == 0.0 && 
				x1_new - x1_old == 0.0 && 
				10.0 * v1_new <= 3.0 && 
				x1_old <= 1.0 && 
				x2_old <= 3.0 && 
				v2_old <= 0.0 && 
				t_new <= 1.0 && 
				t_new >= 0.0 && 
				10.0 * v2_old >= 0.0 - 3.0 && 
				x2_old >= 2.0 && 
				x1_old >= 0.0 && 
				10.0 * v1_new >= 0.0 - 3.0);
		
		// invariant
		assume (x1_new >= 0.0 - eps && x1_new <= 1.0 + eps);
		assume (x2_new >= 2.0 - eps && x2_new <= 3.0 + eps);
		
		x1 := x1_new;
		x2 := x2_new;
		v1 := v1_new;
		v2 := v2_new;
		t := t_new;
		
		// transitions
		if (*) {
			goto loc_6;
		} else {
			goto end;
		}

loc_7:
		x1_old := x1;
		x2_old := x2;
		v1_old := v1;
		v2_old := v2;
		t_old := t;
		
		// invariant
		assume (x1_old >= 1.0 - eps && x1_old <= 2.0 + eps);
		assume (x2_old >= 2.0 - eps && x2_old <= 3.0 + eps);
		
		havoc x1_new;
		havoc x2_new;
		havoc v1_new;
		havoc v2_new;
		havoc t_new;
		
		// flow
		assume ( 572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old == 0.0 && 
				2000000.0 * x1_new - 24000001.0 * x2_new - 20000000.0 * v2_new - 2000000.0 * x1_old + 24000001.0 * x2_old + 20000000.0 * v2_old - 2000000.0 * t_new == 0.0 && 
				2900000240000005.0 * x2_new + 2400000100000000.0 * v2_new - 2900000240000005.0 * x2_old - 2400000100000000.0 * v2_old - 404000041000001.0 * t_new <= 0.0 && 
				960000040000000.0 * x2_new + 400000000000000.0 * v2_new - 960000040000000.0 * x2_old - 400000000000000.0 * v2_old - 544000048000001.0 * t_new <= 0.0 && 
				572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old <= 12000000000000.0 && 
				120000005.0 * x2_new + 100000000.0 * v2_new - 120000005.0 * x2_old - 100000000.0 * v2_old - 18000001.0 * t_new <= 0.0 && 
				24000001.0 * x2_new + 20000000.0 * v2_new + 2000000.0 * x1_old - 24000001.0 * x2_old - 20000000.0 * v2_old + 2000000.0 * t_new <= 4000000.0 && 
				20000000.0 * x2_new - 20000000.0 * x2_old - 26000001.0 * t_new <= 0.0 && 
				x2_new <= 3.0 && 
				x1_old <= 2.0 && 
				x2_old <= 3.0 && 
				v2_old <= 0.0 && 
				t_new <= 1.0 && 
				10.0 * v2_old >= 0.0 - 3.0 && 
				x2_old >= 2.0 && 
				x1_old >= 1.0 && 
				x2_new >= 2.0 && 
				20000000.0 * x2_new - 20000000.0 * x2_old + 34000001.0 * t_new >= 0.0 && 
				24000001.0 * x2_new + 20000000.0 * v2_new + 2000000.0 * x1_old - 24000001.0 * x2_old - 20000000.0 * v2_old + 2000000.0 * t_new >= 2000000.0 && 
				240000010.0 * x2_new + 200000000.0 * v2_new - 240000010.0 * x2_old - 200000000.0 * v2_old + 52000001.0 * t_new >= 0.0 && 
				572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old >= 0.0 - 12000000000000.0 && 
				960000040000000.0 * x2_new + 400000000000000.0 * v2_new - 960000040000000.0 * x2_old - 400000000000000.0 * v2_old + 768000054000001.0 * t_new >= 0.0 && 
				5800000480000010.0 * x2_new + 4800000200000000.0 * v2_new - 5800000480000010.0 * x2_old - 4800000200000000.0 * v2_old + 1208000074000001.0 * t_new >= 0.0 );
		
		// invariant
		assume (x1_new >= 1.0 - eps && x1_new <= 2.0 + eps);
		assume (x2_new >= 2.0 - eps && x2_new <= 3.0 + eps);
		
		x1 := x1_new;
		x2 := x2_new;
		v1 := v1_new;
		v2 := v2_new;
		t := t_new;
		
		// transitions
		if (*) {
			// assignment
			t := 0.0;
			goto loc_7;
		} else if (*) {
			// guard
			assume (x2 <= 2.0 + eps && v2 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_4;
		} else if (*) {
			// guard
			assume (x1 <= 1.0 + eps && v1 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_6;
		} else if (*) {
			// guard
			assume (x1 >= 2.0 - eps && v1 >= 0.0);
			// assignment
			t := 0.0;
			goto loc_8;
		} else {
			goto end;
		}

loc_8:
		x1_old := x1;
		x2_old := x2;
		v1_old := v1;
		v2_old := v2;
		t_old := t;
		
		// invariant
		assume (x1_old >= 2.0 - eps && x1_old <= 3.0 + eps);
		assume (x2_old >= 2.0 - eps && x2_old <= 3.0 + eps);
		
		havoc x1_new;
		havoc x2_new;
		havoc v1_new;
		havoc v2_new;
		havoc t_new;
		
		// flow
		assume ( 572000048000001.0 * x2_new + 40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old + 572000048000001.0 * t_new == 0.0 && 
				572000048000001.0 * x1_new + 480000020000000.0 * v1_new + 40000000000000.0 * v2_new - 572000048000001.0 * x1_old - 480000020000000.0 * v1_old - 40000000000000.0 * v2_old == 0.0 && 
				232000019200000400000000000000.0 * v1_new + 38400001600000000000000000000.0 * v2_new - 232000019200000400000000000000.0 * v1_old - 38400001600000000000000000000.0 * v2_old - 393536063912003852000102000001.0 * t_new <= 0.0 && 
				19200000800000000000000000000.0 * v1_new + 116000009600000200000000000000.0 * v2_new - 19200000800000000000000000000.0 * v1_old - 116000009600000200000000000000.0 * v2_old - 234520043132002950000089000001.0 * t_new <= 0.0 && 
				9600000400000000000000.0 * v1_new + 800000000000000000000.0 * v2_new - 9600000400000000000000.0 * v1_old - 800000000000000000000.0 * v2_old - 18304002108000080000001.0 * t_new <= 0.0 && 
				400000000000000000000.0 * v1_new + 4800000200000000000000.0 * v2_new - 400000000000000000000.0 * v1_old - 4800000200000000000000.0 * v2_old - 10296001436000066000001.0 * t_new <= 0.0 && 
				480000020000000.0 * v1_new + 40000000000000.0 * v2_new - 572000048000001.0 * x1_old - 480000020000000.0 * v1_old - 40000000000000.0 * v2_old <= 0.0 - 1144000096000002.0 && 
				40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old + 572000048000001.0 * t_new <= 0.0 - 1144000096000002.0 && 
				x1_old <= 3.0 && 
				10.0 * v1_old <= 3.0 && 
				x2_old <= 3.0 && 
				v2_old <= 0.0 && 
				t_new <= 1.0 && 
				10.0 * v2_old >= 0.0 - 3.0 && 
				x2_old >= 2.0 && 
				10.0 * v1_old >= 0.0 - 3.0 && 
				x1_old >= 2.0 && 
				40000000000000.0 * v1_new + 480000020000000.0 * v2_new - 40000000000000.0 * v1_old - 572000048000001.0 * x2_old - 480000020000000.0 * v2_old + 572000048000001.0 * t_new >= 0.0 - 1716000144000003.0 && 
				480000020000000.0 * v1_new + 40000000000000.0 * v2_new - 572000048000001.0 * x1_old - 480000020000000.0 * v1_old - 40000000000000.0 * v2_old >= 0.0 - 1716000144000003.0 && 
				800000000000000000000.0 * v1_new + 9600000400000000000000.0 * v2_new - 800000000000000000000.0 * v1_old - 9600000400000000000000.0 * v2_old + 26312002780000094000001.0 * t_new >= 0.0 && 
				9600000400000000000000.0 * v1_new + 800000000000000000000.0 * v2_new - 9600000400000000000000.0 * v1_old - 800000000000000000000.0 * v2_old + 19448002204000082000001.0 * t_new >= 0.0 && 
				38400001600000000000000000000.0 * v1_new + 232000019200000400000000000000.0 * v2_new - 38400001600000000000000000000.0 * v1_old - 232000019200000400000000000000.0 * v2_old + 608608089968004900000116000001.0 * t_new >= 0.0 && 
				232000019200000400000000000000.0 * v1_new + 38400001600000000000000000000.0 * v2_new - 232000019200000400000000000000.0 * v1_old - 38400001600000000000000000000.0 * v2_old + 432432067176003920000102000001.0 * t_new >= 0.0 );
		
		// invariant
		assume (x1_new >= 2.0 - eps && x1_new <= 3.0 + eps);
		assume (x2_new >= 2.0 - eps && x2_new <= 3.0 + eps);
		
		x1 := x1_new;
		x2 := x2_new;
		v1 := v1_new;
		v2 := v2_new;
		t := t_new;
		
		// transitions
		if (*) {
			// assignment
			t := 0.0;
			goto loc_8;
		} else if (*) {
			// guard
			assume (x2 <= 2.0 + eps && v2 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_5;
		} else if (*) {
			// guard
			assume (x1 <= 2.0 + eps && v1 <= 0.0);
			// assignment
			t := 0.0;
			goto loc_7;
		} else {
			goto end;
		}		
		
end:
	// target state space
	assert !( x1 >= 2.0 && x1 <= 3.0 && x2 >= 0.0 && x2 <= 1.0 );
}