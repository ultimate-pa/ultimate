/*
 * 3rd Example test case for stratified reduction with dynamic abstractions.
 *
 */

// We specify commutativity for each set of variables.
//@ commutativity ({x, y}, c, b) ({x, y}, b, c) ({x}, a, b) ({x}, b, a)

// We specify the variables of each proof, separated by |.
//@ proof variables x | x, y | z, y

// Automaton state names for the input should have one conjunct for each proof (so 3 in this case),
// separated by |. States should be accepting if and only if one conjunct is "false".

FiniteAutomaton input = (
     alphabet      = {a b c},
     states        = {"true|true|true" "x=0|true|true" "false|y=x|true" "true|y=0|true" "true|true|z=y" "true|true|y>x"},
     initialStates = {"true|true|true"},
     finalStates   = {"false|y=x|true"},
     transitions   = {
         ("true|true|true" a "x=0|true|true")
         ("x=0|true|true" b "false|y=x|true")
         ("true|true|true" b "true|y=0|true")
         ("true|y=0|true" a "true|true|z=y")
         ("false|y=x|true" c "true|true|y>x")
         ("true|true|y>x" c "false|y=x|true")
     }
);

FiniteAutomaton expected = (
     alphabet      = {a b c},
     states        = {"s0: true|true|true" "s1: x=0|true|true" "s3: false|y=x|true" "s2: true|y=0|true" "s5: true|true|z=y" "s4: true|true|y>x"},
     initialStates = {"s0: true|true|true"},
     finalStates   = {"s3: false|y=x|true"},
     transitions   = {
         ("s0: true|true|true" a "s1: x=0|true|true")
         ("s1: x=0|true|true" b "s3: false|y=x|true")
         ("s0: true|true|true" b "s2: true|y=0|true")
         ("s2: true|y=0|true" a "s5: true|true|z=y")
         ("s3: false|y=x|true" c "s4: true|true|y>x")
         ("s4: true|true|y>x" c "s3: false|y=x|true")
     }
);

