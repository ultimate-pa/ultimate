(set-option :produce-proofs true)
(set-logic AUFLIRA)
(declare-fun po_ ( Int Int) Bool)
(declare-fun v__new__0 () Int)
(declare-fun mod$ ( Int Int) Int)
(declare-fun v__new__1 () Int)
(declare-fun div$ ( Int Int) Int)
(declare-fun v__L__1 () Int)
(declare-fun v__L__0 () Int)
(declare-fun v_new_init () Int)
(declare-fun v__auld__1 () Int)
(declare-fun v__auld__0 () Int)
(declare-fun v_L_0 () Int)
(declare-fun v_L_2 () Int)
(declare-fun v_auld_2 () Int)
(declare-fun v__L () Int)
(assert (! (let ((v_L_1 v_L_0)) (= v_L_1 0)) :named IP_0))
(assert (! true :named IP_1))
(assert (! (let ((v_L_11 v_L_2)) (let ((v_auld_10 v_auld_2)) (let ((v_L_12 v_L_0)) (let ((v_new_11 v_new_init)) (and (not (= v_L_12 1)) (= v_L_11 1) (= v_auld_10 v_new_11)))))) :named IP_2))
(assert (! (let ((v_auld_26 v_auld_2)) (let ((v_new_26 v_new_init)) (not (= v_new_26 v_auld_26)))) :named IP_3))
(assert (! true :named IP_4))
(assert (! (let ((v_L_8 v_L_2)) (= v_L_8 1)) :named IP_5))
(check-sat)
(get-interpolants IP_0 IP_1 IP_2 IP_3 IP_4 IP_5)
(exit)
