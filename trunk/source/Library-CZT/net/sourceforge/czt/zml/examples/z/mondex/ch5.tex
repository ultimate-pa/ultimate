\chapter{\Betw\ model, promoted world}\label{ch5}

\begin{zsection}
  \SECTION ch5 \parents ch4
\end{zsection}

\section{The world}

\begin{LConsistency}[$Logbook$ consistency]
\begin{zeves-theorem}{tLogbookConsistency}
    \exists Logbook: \power~(NAMES \rel PayDetails) @ \\
        \t1 Logbook = \power~(\{~PayDetails @ from \mapsto \theta PayDetails~\} \cup \\
             \t2 \{~PayDetails @ to \mapsto \theta PayDetails ~\})
\end{theorem}~\end{LConsistency}

\begin{LADef}[Log book of payments]
\begin{axdef}
   Logbook: \power~(NAMES \rel PayDetails)
\where
%   \Label{disabled rule dLogbook}
   Logbook = \power~(\{~PayDetails @ from \mapsto \theta PayDetails~\} \cup \\
      \t2 \{~PayDetails @ to \mapsto \theta PayDetails ~\})
\end{axdef}~\end{LADef}
%
\begin{LSDef}[Concrete world]
\begin{schema}{ConWorld}
   conAuthPurse: NAMES \finj ConPurse \\
   ether: \power~MESSAGE \\
   archive: Logbook
\where
   \forall n: \dom~conAuthPurse @ (conAuthPurse~n).name = n
   \also
   \forall nld: archive @ first~nld \in \dom~conAuthPurse
\end{schema}~\end{LSDef}


\section{Auxiliary definitions}\label{ch5.auxworld}

Now, we leave the definition of $AuxWorld$ without mentioning
any finiteness properties, but prove it later as a consequence of
the involved sets being restricted to the domain of the finite injection $conAuthPurse$
from $ConWorld$.
%
\begin{LSDef}[Auxiliary definitions for the concrete world]
\begin{schema}{AuxWorld}
   ConWorld
   \also
   allLogs: NAMES \rel PayDetails \\
   authenticFrom, authenticTo: \power~PayDetails \\
   fromLogged, toLogged: \power~PayDetails \\
   toInEpv, toInEapayee, fromInEpr, fromInEpa: \power~PayDetails \\
   definitelyLost: \power~PayDetails \\
   maybeLost: \power~PayDetails
\where
%   \znote{Finiteness of components left out for better automation.}
%   \znote{They are proved as theorems instead, because conAuthPurse}
%   \znote{is finite anyway.}
   toInEpv \in \finset~PayDetails \\
   toInEapayee \in \finset~PayDetails \\
   fromInEpr \in \finset~PayDetails \\
   fromInEpa \in \finset~PayDetails \\
   maybeLost \in \finset~PayDetails
   \also
   fromLogged = \{~ pd: authenticFrom | pd.from \mapsto pd \in allLogs ~\} \\
   toLogged = \{~ pd: authenticTo | pd.to \mapsto pd \in allLogs ~\}
   \also
%   \znote{See comment above on the definition of ConWorld}
   authenticFrom \\
      \t1 = \{~ pd: PayDetails | pd.from \in \dom~conAuthPurse~\} \\
   authenticTo \\
      \t1 = \{~ pd: PayDetails | pd.to \in \dom~conAuthPurse~\}
   \also
   toInEpv = \{~ pd: authenticTo | \\
          \t3 (conAuthPurse~pd.to).status = epv \\
          \t2 \land (conAuthPurse~pd.to).pdAuth = pd ~\} \\
   toInEapayee = \{~ pd: authenticTo | \\
          \t3 (conAuthPurse~pd.to).status = eaTo \\
          \t2 \land (conAuthPurse~pd.to).pdAuth = pd ~\} \\
   fromInEpr = \{~ pd: authenticFrom | \\
          \t3 (conAuthPurse~pd.from).status = epr \\
          \t2 \land (conAuthPurse~pd.from).pdAuth = pd ~\} \\
   fromInEpa = \{~ pd: authenticFrom | \\
          \t3 (conAuthPurse~pd.from).status = epa \\
          \t2 \land (conAuthPurse~pd.from).pdAuth = pd ~\}
   \also
   allLogs = archive \cup \\
      \t2 \{~ n: \dom~conAuthPurse; pd: PayDetails | pd \in (conAuthPurse~n).exLog ~\}
   \also
   definitelyLost = toLogged \cap (fromLogged \cup fromInEpa) \\
   maybeLost = (fromInEpa \cup fromLogged) \cap toInEpv
\end{schema}~\end{LSDef}
%
\begin{LThm}[Auxiliary world elements identity]
\begin{zeves-theorem}{tAuxWorldIdentity}
   \forall AuxWorld @ definitelyLost \cup maybeLost = \\
        \t1 (fromInEpa \cup fromLogged) \cap (toInEpv \cup toLogged)
\end{theorem}~\end{LThm}

\subsection{Added information about finiteness}

% These are thanks to Mark Saaltink

From the original document, it was left implicit that $authenticFrom$ and $authenticTo$ were finite as well.
Thus, we explicitly prove that both $authenticFrom$ and $authenticTo$ are finite, something missing from
the original definition. Before adding the necessary forward rules, we need some extra lemmas about the
finiteness of particular $PayDetails$ sets.

\subsubsection{Extending the toolkit}

\begin{LToolkit}[Improved version of toolkit rule $crossFinite$]
\begin{zeves-theorem}{rule rCrossFinite}
  A \cross B \in \finset (C \cross D) \iff \\\t1
  A = \{\} \lor B = \{\} \lor (A \in \finset C \land B \in \finset D)
\end{theorem}~\end{LToolkit}

\begin{LToolkit}[Subset of finite set is finite]
\begin{zeves-theorem}{lFinsetSubset}
  X \in \power Y \land Y \in \finset Z \implies X \in \finset Z
\end{theorem}~\end{LToolkit}

\subsubsection{$PayDetails$ bindings are finite}

To prove these lemmas, we need to establish a basic theory for $PayDetais$ finiteness first.
As we have already included finite types in $PayDetails$, it becomes possible to prove a more basic
fact needed for the lemmas mentioned above. That is, the set of bindings $PayDetails$ represent is itself finite
%
\begin{gzed}
   PayDetails \in \finset \lblot from: NAME; to: NAME; value: \num; fromSeqNo: \num; toSeqNo: \num \rblot
\end{gzed}
%
To prove this basic lemma, we need to establish some facts about finiteness in general, they are given below.
Firstly, let us define the space under concern as the cross product of $PayDetails$ components
shaped as
\begin{gzed}
((from, to), (value, (fromSeqNo, toSeqNo)))
\end{gzed}
%
\begin{LNewADef}[Possible values for $PayDetails$ components]
\begin{zed}
   PayDetailsSpace == (NAMES \cross NAMES) \cross (NAT \cross (NAT \cross NAT))
\end{zed}~\end{LNewADef}

\begin{LNewADef}[Possible values for $PayDetails$ bindings]
\begin{zed}
   PayDetailsBindings == \\
    \t1 \{ PayDetails @ (((from, to), (value, (fromSeqNo, toSeqNo))), \theta PayDetails) \}
\end{zed}~\end{LNewADef}

\begin{LNewLemma}[$PayDetails$ space is finite]
\begin{zeves-theorem}{lPayDetailsSpaceFiniteMaxType}
    PayDetailsSpace \in \finset~((NAME \cross NAME) \cross (\num \cross (\num \cross \num)))
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ bindings are within $PayDetails$ space]
\begin{zeves-theorem}{lPayDetailsBindingsSubsetPayDetailsSpace}
    \dom~PayDetailsBindings \in \power~PayDetailsSpace
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ bindings are finite]
\begin{zeves-theorem}{lPayDetailsBindingsFiniteMaxType}
    \dom~PayDetailsBindings \in \finset~((NAME \cross NAME) \cross (\num \cross (\num \cross \num)))
\end{theorem}~\end{LNewLemma}

\begin{LGRT}[$PayDetails$ bindings maximal $\pfun$ type]
\begin{zeves-theorem}{grule gPayDetailsBindingsPfun}
    PayDetailsBindings \in ((NAME \cross NAME) \cross (\num \cross (\num \cross \num))) \pfun PayDetails
\end{theorem}~\end{LGRT}

\begin{LGRT}[$PayDetails$ bindings maximal $\ffun$ type]
\begin{zeves-theorem}{grule gPayDetailsBindingsFfun}
    PayDetailsBindings \in ((NAME \cross NAME) \cross (\num \cross (\num \cross \num))) \ffun PayDetails
\end{theorem}~\end{LGRT}

\begin{LNewLemma}[$PayDetails$ bindings encompass the whole of $PayDetails$]
\begin{zeves-theorem}{rule lPayDetailsBindinsRange}
    \ran~PayDetailsBindings = PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ is a finite set of its bindings]
\begin{zeves-theorem}{grule lPayDetailsIsFinite}
    PayDetails \in \finset~\lblot from: NAME; fromSeqNo: \num; to: NAME; toSeqNo: \num; value: \num \rblot
\end{theorem}~\end{LNewLemma}

\subsubsection{$PayDetails$ sets that we are interested in are finite}

\begin{LNewLemma}[$PayDetails$ fixed $from$ is finite]
\begin{zeves-theorem}{rule lPayDetailsFromPurseNameFinite}
    \forall name: NAMES @ \{~  pd: PayDetails | pd.from = name ~\} \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ fixed $to$ is finite]
\begin{zeves-theorem}{rule lPayDetailsToPurseNameFinite}
    \forall name: NAMES @ \{~  pd: PayDetails | pd.to = name ~\} \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ $from$ purse from $\dom$ is finite]
\begin{zeves-theorem}{rule lPayDetailsFromPurseDomainFinite}
    \forall purse: NAMES \finj ConPurse  @ \\
        \t1 \{~  pd: PayDetails | pd.from \in \dom~purse ~\} \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ $to$ purse from $\dom$ is finite]
\begin{zeves-theorem}{rule lPayDetailsToPurseDomainFinite}
    \forall purse: NAMES \finj ConPurse  @ \\
        \t1 \{~  pd: PayDetails | pd.to \in \dom~purse ~\} \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}


Now, from the definition of $AuxWorld$, the necessary theorems about its components is trivial.
%
\begin{LFRT}[$AuxWorld$ $authenticFrom$ is finite]
\begin{zeves-theorem}{frule fAuxWorldAuthenticFromIsFinite}
   \forall AuxWorld @ authenticFrom \in \finset~PayDetails
\end{theorem}~\end{LFRT}
%
\begin{LFRT}[$AuxWorld$ $authenticFrom$ is finite]
\begin{zeves-theorem}{frule fAuxWorldAuthenticToIsFinite}
   \forall AuxWorld @ authenticTo \in \finset~PayDetails
\end{theorem}~\end{LFRT}

\subsection{$AuxWorld$ does not add constraints}

\begin{LSDef}[Concrete world auxiliary definitions relationship]
\begin{zed}
   NewVariables ~~\defs~~ \exists ConWorld @ AuxWorld
\end{zed}~\end{LSDef}

For the next theorem, because of the way finiteness is encoded in Mondex,
we need additional lemmas. Furthermore, because \zeves\ does not accept
using complex expressions (with schema binding selection within set comprehension)
in the middle of a proof, we need to cover these finiteness properties through
axiomatic definitions.

Firstly, we add those payments related to the domain of authentic purses.
%
\begin{LNewADef}[$PayDetails$ elements for $from$ $purse$]
\begin{axdef}
   PayDetailsFromDomPurse: \power~PayDetails
\where
%  \Label{rule dPayDetailsFromDomPurse}
    \forall purse: NAMES \finj ConPurse @ PayDetailsFromDomPurse = \\
    \t1 \{~ pd: PayDetails | pd.from \in \dom~purse ~\}
\end{axdef}~\end{LNewADef}

TODO: Add consistency lambda-terms here! See Z/Eves user's guide p.22 (3.1.3).
%%\exists PayDetailsFromDomPurse: \power~PayDetails @ \\
%%    \t1 \forall purse: NAMES \finj ConPurse @ PayDetailsFromDomPurse = \\
%%        \t2 \{~ pd: PayDetails | pd.from \in \dom~purse ~\}
%%
\begin{LNewADef}[$PayDetails$ elements for $to$ $purse$]
\begin{axdef}
   PayDetailsToDomPurse: \power~PayDetails
\where
%  \Label{rule dPayDetailsToDomPurse}
    \forall purse: NAMES \finj ConPurse @ PayDetailsToDomPurse = \\
    \t1 \{~ pd: PayDetails | pd.to \in \dom~purse ~\}
\end{axdef}~\end{LNewADef}
%
Next, we add those payments filtered accordingly.
%
\begin{LNewADef}[$epr$ set of payment details via $from$]
\begin{axdef}
   PayDetailsFromDomEPRPurse: \power~PayDetails
\where
%  \Label{rule dPayDetailsFromDomEPRPurse}
    \forall purse: NAMES \finj ConPurse @ PayDetailsFromDomEPRPurse = \\
    \t1 \{~ pd: \{~ pd1: PayDetails | pd1.from \in \dom~purse ~\} | \\
        \t2 (purse~pd.from).status = epr \\
        \t2 \land (purse~pd.from).pdAuth = pd ~\}
\end{axdef}~\end{LNewADef}
%
\begin{LNewADef}[$epa$ set of payment details via $from$]
\begin{axdef}
   PayDetailsFromDomEPAPurse: \power~PayDetails
\where
%  \Label{rule dPayDetailsFromDomEPAPurse}
    \forall purse: NAMES \finj ConPurse @ PayDetailsFromDomEPAPurse = \\
    \t1 \{~ pd: \{~ pd1: PayDetails | pd1.from \in \dom~purse ~\} | \\
        \t2 (purse~pd.from).status = epa \\
        \t2 \land (purse~pd.from).pdAuth = pd ~\}
\end{axdef}~\end{LNewADef}
%
\begin{LNewADef}[$epv$ set of payment details via $to$]
\begin{axdef}
   PayDetailsToDomEPVPurse: \power~PayDetails
\where
% \Label{rule dPayDetailsToDomEPVPurse}
    \forall purse: NAMES \finj ConPurse @ PayDetailsToDomEPVPurse = \\
    \t1 \{~ pd: \{~ pd1: PayDetails | pd1.to \in \dom~purse ~\} | \\
        \t2 (purse~pd.to).status = epv \land \\
        \t2 (purse~pd.to).pdAuth = pd ~\}
\end{axdef}~\end{LNewADef}
%
\begin{LNewADef}[$eaTo$ set of payment details via $to$]
\begin{axdef}
   PayDetailsToDomEATOPurse: \power~PayDetails
\where
%  \Label{rule dPayDetailsToDomEATOPurse}
    \forall purse: NAMES \finj ConPurse @ PayDetailsToDomEATOPurse = \\
    \t1 \{~ pd: \{~ pd1: PayDetails | pd1.to \in \dom~purse ~\} | \\
        \t2 (purse~pd.to).status = eaTo \land \\
        \t2 (purse~pd.to).pdAuth = pd ~\}
\end{axdef}~\end{LNewADef}
%
After that, we add the necessary lemmas
%
\begin{LNewLemma}[$PayDetailsFromDomEPRPurse$ is finite]
\begin{zeves-theorem}{rule lPayDetailsFromPurseEPRIsFinite}
    \forall purse: NAMES \finj ConPurse @ PayDetailsFromDomEPRPurse \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$epa$ set of payment details is finite via $from$]
\begin{zeves-theorem}{rule lPayDetailsFromPurseEPAIsFinite}
    \forall purse: NAMES \finj ConPurse @ PayDetailsFromDomEPAPurse \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$epv$ set of payment details is finite via $to$]
\begin{zeves-theorem}{rule lPayDetailsToPurseEPVIsFinite}
    \forall purse: NAMES \finj ConPurse @ PayDetailsToDomEPVPurse \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$eaTo$ set of payment details is finite via $to$]
\begin{zeves-theorem}{rule lPayDetailsToPurseEATOIsFinite}
    \forall purse: NAMES \finj ConPurse @ PayDetailsToDomEATOPurse \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}
%
And finally, we prove the original Mondex theorem.
%
\begin{LThm}[$AuxWorld$ do not add constraints to $ConWorld$] %
\begin{zeves-theorem}{tAuxWorldDoesNotAddConstraints}
   \forall ConWorld @ \exists_1 NewVariables @ AuxWorld
\end{theorem}~\end{LThm}

\section{Constraints on the ether}\label{ch5.betweenworld}

Due to the sheer size and complexity of the generated domain check proof,
we decided to define $BetweenWorld$ by layering its properties via schema
inclusion. This allows not only a smoother but also much faster proof.
Essentially, we are factoring each case of the original proof with schemas.

This is also a good idea because the assumptions immediately available for
each domain check case from the original $BetweenWorld$ are given
in sequence according to the declared schema predicates. Otherwise, if we
had tried to prove the monolithic version, we would need a plethora of auxiliary
lemmas.

This layering also shows the interrelationship between different properties,
and what predicates they depend upon. In the end, we just combine all properties
to form the complete $BetweenWorld$. This layering idea comes from previous
experience with a ZRC proof the a refinement model checking algorithm.

\begin{LNewSDef}[Between world property $B1$]
\begin{schema}{BetweenWorldB1}
   AuxWorld
\where
   \forall pd : PayDetails | req~pd \in ether @ pd \in authenticTo
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B2$]
\begin{schema}{BetweenWorldB2}
   AuxWorld
\where
   BetweenWorldB1
   \also
   \forall pd : PayDetails | req~pd \in ether @
  \\ %
  \t1 pd.toSeqNo < (conAuthPurse~pd.to).nextSeqNo
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[\textbf{Missing between world property for~}$\mathbf{B3}$]
\begin{schema}{BetweenWorldNEW1}
   AuxWorld
\where
   \forall pd : PayDetails | val~pd \in ether @ pd \in authenticTo
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[\textbf{Missing between world property for~}$\mathbf{B3}$]
\begin{schema}{BetweenWorldNEW2}
   AuxWorld
\where
   \forall pd : PayDetails | val~pd \in ether @ pd \in authenticFrom
\end{schema}~\end{LNewSDef}

For property $B3$, the original purse was missing additional information about the
authenticity of $val$ messages in the $ether$ for $to$ and $from$ purses. This did
not happen for $rel$ messages, as property $B1$ shows.
Moreover, we include the new properties in the predicate part to have a uniform signature
across  $BetweenWorld$ properties. Although not strictly necessary, it helps \zeves\ while
performing reduction or automatically applying forward ($frules$) rules.
%
\begin{LNewSDef}[Between world property $B3$]
\begin{schema}{BetweenWorldB3}
   AuxWorld
\where
   BetweenWorldNEW1 \\
   BetweenWorldNEW2
   \also
   \forall pd : PayDetails | val~pd \in ether @
  \\ %
  \t1 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo
  \\ %
  \t1 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[\textbf{Missing between world property for~}$\mathbf{B4}$]
\begin{schema}{BetweenWorldNEW3}
   AuxWorld
\where
   \forall pd : PayDetails | ack~pd \in ether @ pd \in authenticTo
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[\textbf{Missing between world property for~}$\mathbf{B4}$]
\begin{schema}{BetweenWorldNEW4}
   AuxWorld
\where
   \forall pd : PayDetails | ack~pd \in ether @ pd \in authenticFrom
\end{schema}~\end{LNewSDef}

Similarly, for property $B4$, we need to include the authenticity of
$ack$ messages in the $ether$ for $to$ and $from$ purses.
%
\begin{LNewSDef}[Between world property $B4$]
\begin{schema}{BetweenWorldB4}
   AuxWorld
\where
   BetweenWorldNEW3 \\
   BetweenWorldNEW4
   \also
   \forall pd : PayDetails | ack~pd \in ether @
  \\ %
  \t1 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo
  \\ %
  \t1 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo
\end{schema}~\end{LNewSDef}

For $B5$ nothing else is needed because the $from$ purses in $fromLogged$ are already authentic,
as given by its definition in $AuxWorld$.
%
\begin{LNewSDef}[Between world property $B5$]
\begin{schema}{BetweenWorldB5}
   AuxWorld
\where
    \forall pd : fromLogged @
  \\ %
  \t1 pd.fromSeqNo < (conAuthPurse~pd.from).nextSeqNo
\end{schema}~\end{LNewSDef}

Similarly, for $B6$ $B7$ and $B8$, the $to$ purses in $toLogged$ and $from$ purses in $fromLogged$
are already authentic as well.
%
\begin{LNewSDef}[Between world property $B6$]
\begin{schema}{BetweenWorldB6}
   AuxWorld
\where
   \forall pd : toLogged @ pd.toSeqNo < (conAuthPurse~pd.to).nextSeqNo
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B7$]
\begin{schema}{BetweenWorldB7}
   AuxWorld
\where
\forall pd : fromLogged |
  \\ %
  \t1 (conAuthPurse~pd.from).status \in \{epr,epa\} @
  \\ %
  \t1 pd.fromSeqNo
  \\ %
  \t2 < (conAuthPurse~pd.from).pdAuth.fromSeqNo
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B8$]
\begin{schema}{BetweenWorldB8}
   AuxWorld
\where
\forall pd : toLogged | (conAuthPurse~pd.to).status \in \{
  epv,eaTo \} @
  \\ %
  \t1 pd.toSeqNo < (conAuthPurse~pd.to).pdAuth.toSeqNo
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B9$]
\begin{schema}{BetweenWorldB9}
   AuxWorld
\where
\forall pd : fromInEpr @ \disjoint \langle \{ val~pd, ack~pd \} ,
  ether \rangle
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B10$]
\begin{schema}{BetweenWorldB10}
   AuxWorld
\where
\forall pd : PayDetails @
  \\ %
  \t1 (req~pd \in ether \land ack~pd \notin ether~)
  \\ %
  \t2 \iff (pd \in toInEpv \cup toLogged)
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B11$]
\begin{schema}{BetweenWorldB11}
   AuxWorld
\where
\forall pd : PayDetails | val~pd \in ether \land pd \in toInEpv @
  \\ %
  \t1 pd \in fromInEpa \cup fromLogged
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B12$]
\begin{schema}{BetweenWorldB12}
   AuxWorld
\where
\forall pd : fromInEpa \cup fromLogged @  req~pd \in ether
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B13$]
\begin{schema}{BetweenWorldB13}
   AuxWorld
\where
toLogged \in \finset PayDetails
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B14$]
\begin{schema}{BetweenWorldB14}
   AuxWorld
\where
\forall pd : exceptionLogResult\inv \limg ether \rimg @ pd \in
  allLogs
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B15$]
\begin{schema}{BetweenWorldB15}
   AuxWorld
\where
\forall pds : \power_1 PayDetails; name : NAMES |
  \\ %
  \t2 exceptionLogClear~(name, image~pds) \in ether @
  \\ %
  \t1 \{name\} \cross pds \subseteq archive
\end{schema}~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B16$]
\begin{schema}{BetweenWorldB16}
   AuxWorld
\where
\forall pd: fromLogged \cup toLogged @ req~pd \in ether
\end{schema}~\end{LNewSDef}

\begin{LSDef}[Complete between world definition]
\begin{zed}
   BetweenWorld \defs BetweenWorldB1 \land BetweenWorldB2 \land \\
                BetweenWorldB3 \land BetweenWorldB4 \land \\
                BetweenWorldB5 \land BetweenWorldB6 \land \\
                BetweenWorldB7  \land BetweenWorldB8 \land \\
                BetweenWorldB9 \land BetweenWorldB10 \land \\
                BetweenWorldB11 \land BetweenWorldB12 \land \\
                BetweenWorldB13 \land BetweenWorldB14 \land \\
                BetweenWorldB15 \land BetweenWorldB16
\end{zed}~\end{LSDef}

\subsection*{Expanded $BetweenWorld$}

Cannot be a rule because of quantifiers in the goal.
%
\begin{LNewLemma}[Between world simple expansion]
\begin{zeves-theorem}{lBetweenWorldExpansion}
    \forall BetweenWorld @
    \znote{BetweenWorld components}
    AuxWorld \land \\ \t1
    \znote{BetweenWorld invariant}
    (\forall pd : PayDetails | req~pd \in ether @ pd \in authenticTo) \\
    \land
    (\forall pd : PayDetails | req~pd \in ether @ \\
        \t1 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo) \\
    \land
    (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticTo) \\
    \land
    (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticFrom) \\
    \land
    (\forall pd : PayDetails | val~pd \in ether @ \\
        \t1 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo \\
        \t1 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \\
    \land
    (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticTo) \\
    \land
    (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticFrom) \\
    \land
    (\forall pd : PayDetails | ack~pd \in ether @ \\
        \t1 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo  \\ %
        \t1 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \\
    \land %
    (\forall pd : fromLogged @  \\ %
        \t1 pd.fromSeqNo < (conAuthPurse~pd.from).nextSeqNo) \\
    \land %
    (\forall pd : toLogged @ pd.toSeqNo < (conAuthPurse~pd.to).nextSeqNo) \\
    \land %
    (\forall pd : fromLogged | \\ %
        \t1 (conAuthPurse~pd.from).status \in \{epr,epa\} @  \\ %
        \t2 pd.fromSeqNo \\ %
        \t2 < (conAuthPurse~pd.from).pdAuth.fromSeqNo) \\
    \land %
    (\forall pd : toLogged | (conAuthPurse~pd.to).status \in \{ epv,eaTo \} @ \\ %
        \t1 pd.toSeqNo < (conAuthPurse~pd.to).pdAuth.toSeqNo) \\
    \land %
    (\forall pd : fromInEpr @ \disjoint \langle \{ val~pd, ack~pd \} , ether \rangle) \\
    \land %
    (\forall pd : PayDetails @ \\ %
        \t1 (req~pd \in ether \land ack~pd \notin ether~) \\ %
        \t2 \iff (pd \in toInEpv \cup toLogged)) \\
    \land %
    (\forall pd : PayDetails | val~pd \in ether \land pd \in toInEpv @ \\ %
        \t1 pd \in fromInEpa \cup fromLogged) \\
    \land %
    (\forall pd : fromInEpa \cup fromLogged @  req~pd \in ether) \\
    \land %
    (toLogged \in \finset PayDetails) \\
    \land %
    (\forall pd : exceptionLogResult\inv \limg ether \rimg @ pd \in allLogs) \\
    \land %
    (\forall pds : \power_1 PayDetails; name : NAMES | \\ %
            \t2 exceptionLogClear(name, image~pds) \in ether @ \\ %
        \t1 \{name\} \cross pds \subseteq archive) \\
    \land %
    (\forall pd: fromLogged \cup toLogged @ req~pd \in ether)
\end{theorem}~\end{LNewLemma}

Unfortunately, if $AuxWorld$ elements or invariant are needed in proofs, the
next theorem is required. That is because $AuxWorld$ is blown away by \zeves\
when the closed $BetweenWorld$ appears early on the list of assumptions.
%
\begin{LNewLemma}[Between $AuxWorld$ expansion]
\begin{zeves-theorem}{lBetweenWorldAuxWorldExpansion}
    \znote{AuxWorld components}
    \forall BetweenWorld @ ConWorld \land
            allLogs \in NAMES \rel PayDetails \land \\ \t1
            authenticFrom \in \power~PayDetails \land
            authenticTo \in \power~PayDetails \land \\ \t1
            fromLogged \in \power~PayDetails \land
            toLogged \in \power~PayDetails \land \\ \t1
            toInEpv \in \power~PayDetails \land
            toInEapayee \in \power~PayDetails \land \\ \t1
            fromInEpr \in \power~PayDetails \land
            fromInEpa \in \power~PayDetails \land \\ \t1
            definitelyLost \in \power~PayDetails \land
            maybeLost \in \power~PayDetails \land \\
        \znote{AuxWorld invariant} \t1
            toInEpv \in \finset~PayDetails \land \\ \t1
            toInEapayee \in \finset~PayDetails \land
            fromInEpr \in \finset~PayDetails \land \\ \t1
            fromInEpa \in \finset~PayDetails \land
            maybeLost \in \finset~PayDetails \land \\ \t1
            authenticFrom \in \finset PayDetails \land
            authenticTo \in \finset PayDetails \land \\ \t1
            fromLogged = \{~ pd: authenticFrom | pd.from \mapsto pd \in allLogs ~\} \land \\ \t1
            toLogged = \{~ pd: authenticTo | pd.to \mapsto pd \in allLogs ~\} \land \\ \t1
            authenticFrom = \{~ pd: PayDetails | pd.from \in \dom~conAuthPurse~\} \land \\ \t1
            authenticTo = \{~ pd: PayDetails | pd.to \in \dom~conAuthPurse~\} \land \\ \t1
            toInEpv = \{~ pd: authenticTo | (conAuthPurse pd.to).status = epv \\
                    \t4 \land (conAuthPurse pd.to).pdAuth = pd ~\} \land \\ \t1
            toInEapayee = \{~ pd: authenticTo | (conAuthPurse pd.to).status = eaTo \\
                    \t5 \land (conAuthPurse pd.to).pdAuth = pd ~\} \land \\ \t1
            fromInEpr = \{~ pd: authenticFrom | (conAuthPurse pd.from).status = epr \\
                    \t5 \land (conAuthPurse pd.from).pdAuth = pd ~\} \land \\ \t1
            fromInEpa = \{~ pd: authenticFrom | (conAuthPurse pd.from).status = epa \\
                    \t5 \land (conAuthPurse pd.from).pdAuth = pd ~\} \land \\ \t1
            allLogs = archive \cup \\
                \t2 \{~ n: \dom~conAuthPurse; pd: PayDetails | pd \in (conAuthPurse~n).exLog ~\} \land \\ \t1
            definitelyLost = toLogged \cap (fromLogged \cup fromInEpa) \land \\ \t1
            maybeLost = (fromInEpa \cup fromLogged) \cap toInEpv \land \\
    \znote{BetweenWorld invariant}\t1
            (\forall pd : PayDetails | req~pd \in ether @ pd \in authenticTo)
            \land \\ \t1
            (\forall pd : PayDetails | req~pd \in ether @
                 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo) \\ \t1
            \land
            (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticTo) \land \\ \t1
            (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticFrom) \land \\ \t1
            (\forall pd : PayDetails | val~pd \in ether @ pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo \\
                \t2 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticTo)\land  \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticFrom) \land \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo  \\ %
                \t2 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : fromLogged @  pd.fromSeqNo < (conAuthPurse~pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : toLogged @ pd.toSeqNo < (conAuthPurse~pd.to).nextSeqNo) \land  \\ \t1
            (\forall pd : fromLogged | (conAuthPurse~pd.from).status \in \{epr,epa\} @  \\ %
                \t2 pd.fromSeqNo < (conAuthPurse~pd.from).pdAuth.fromSeqNo) \land \\ \t1
            (\forall pd : toLogged | (conAuthPurse~pd.to).status \in \{ epv,eaTo \} @ \\ %
                \t2 pd.toSeqNo < (conAuthPurse~pd.to).pdAuth.toSeqNo) \land \\ \t1
            (\forall pd : fromInEpr @ \disjoint \langle \{ val~pd, ack~pd \} , ether \rangle) \land \\ \t1
            (\forall pd : PayDetails @ (req~pd \in ether \land ack~pd \notin ether~)
                \iff (pd \in toInEpv \cup toLogged)) \\ \t1
            \land (\forall pd : PayDetails | val~pd \in ether \land pd \in toInEpv @ \\ %
                \t3 pd \in fromInEpa \cup fromLogged) \land \\ \t1
            (\forall pd : fromInEpa \cup fromLogged @  req~pd \in ether) \land
            (toLogged \in \finset PayDetails) \land \\ \t1
            (\forall pd : exceptionLogResult\inv \limg ether \rimg @ pd \in allLogs) \land \\ \t1
            (\forall pds : \power_1 PayDetails; name : NAMES | \\ %
                    \t3 exceptionLogClear(name, image~pds) \in ether @ \\ %
                \t4 \{name\} \cross pds \subseteq archive) \land \\ \t1
            (\forall pd: fromLogged \cup toLogged @ req~pd \in ether)
\end{theorem}~\end{LNewLemma}
%
These theorems would be equivalent to having individual forward rules (frule),
one for each invariant property and schema component. (see Chapter~\ref{ch10} for
were it is used).
%
\begin{LNewLemma}[Between world full expansion]
\begin{zeves-theorem}{lBetweenWorldFullExpansion}
    \znote{ConWorld components and invariant}
    \forall BetweenWorld @ conAuthPurse \in NAMES \finj ConPurse \land
            ether \in \power~MESSAGE \land \\ \t1
            archive \in Logbook \land  (\forall n: \dom~conAuthPurse @ (conAuthPurse~n).name = n) \land \\ \t1
            (\forall nld: archive @ first~nld \in \dom~conAuthPurse) \land \\
        \znote{AuxWorld components and invariant} \t1
            allLogs \in NAMES \rel PayDetails \land
            authenticFrom \in \power~PayDetails \land \\ \t1
            authenticTo \in \power~PayDetails \land
            fromLogged \in \power~PayDetails \land \\ \t1
            toLogged \in \power~PayDetails \land
            toInEpv \in \power~PayDetails \land \\ \t1
            toInEapayee \in \power~PayDetails \land
            fromInEpr \in \power~PayDetails \land \\ \t1
            fromInEpa \in \power~PayDetails \land
            definitelyLost \in \power~PayDetails \land \\ \t1
            maybeLost \in \power~PayDetails \land
            toInEpv \in \finset~PayDetails \land \\ \t1
            toInEapayee \in \finset~PayDetails \land
            fromInEpr \in \finset~PayDetails \land \\ \t1
            fromInEpa \in \finset~PayDetails \land
            maybeLost \in \finset~PayDetails \land \\ \t1
            authenticFrom \in \finset PayDetails \land
            authenticTo \in \finset PayDetails \land \\ \t1
            fromLogged = \{~ pd: authenticFrom | pd.from \mapsto pd \in allLogs ~\} \land \\ \t1
            toLogged = \{~ pd: authenticTo | pd.to \mapsto pd \in allLogs ~\} \land \\ \t1
            authenticFrom = \{~ pd: PayDetails | pd.from \in \dom~conAuthPurse~\} \land \\ \t1
            authenticTo = \{~ pd: PayDetails | pd.to \in \dom~conAuthPurse~\} \land \\ \t1
            toInEpv = \{~ pd: authenticTo | (conAuthPurse pd.to).status = epv \\
                    \t4 \land (conAuthPurse pd.to).pdAuth = pd ~\} \land \\ \t1
            toInEapayee = \{~ pd: authenticTo | (conAuthPurse pd.to).status = eaTo \\
                    \t5 \land (conAuthPurse pd.to).pdAuth = pd ~\} \land \\ \t1
            fromInEpr = \{~ pd: authenticFrom | (conAuthPurse pd.from).status = epr \\
                    \t5 \land (conAuthPurse pd.from).pdAuth = pd ~\} \land \\ \t1
            fromInEpa = \{~ pd: authenticFrom | (conAuthPurse pd.from).status = epa \\
                    \t5 \land (conAuthPurse pd.from).pdAuth = pd ~\} \land \\ \t1
            allLogs = archive \cup \\
                \t2 \{~ n: \dom~conAuthPurse; pd: PayDetails | pd \in (conAuthPurse~n).exLog ~\} \land \\ \t1
            definitelyLost = toLogged \cap (fromLogged \cup fromInEpa) \land \\ \t1
            maybeLost = (fromInEpa \cup fromLogged) \cap toInEpv \land \\
    \znote{BetweenWorld invariant}\t1
            (\forall pd : PayDetails | req~pd \in ether @ pd \in authenticTo)
            \land \\ \t1
            (\forall pd : PayDetails | req~pd \in ether @
                 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo) \\ \t1
            \land
            (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticTo) \land \\ \t1
            (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticFrom) \land \\ \t1
            (\forall pd : PayDetails | val~pd \in ether @ pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo \\
                \t2 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticTo)\land  \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticFrom) \land \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo  \\ %
                \t2 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : fromLogged @  pd.fromSeqNo < (conAuthPurse~pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : toLogged @ pd.toSeqNo < (conAuthPurse~pd.to).nextSeqNo) \land  \\ \t1
            (\forall pd : fromLogged | (conAuthPurse~pd.from).status \in \{epr,epa\} @  \\ %
                \t2 pd.fromSeqNo < (conAuthPurse~pd.from).pdAuth.fromSeqNo) \land \\ \t1
            (\forall pd : toLogged | (conAuthPurse~pd.to).status \in \{ epv,eaTo \} @ \\ %
                \t2 pd.toSeqNo < (conAuthPurse~pd.to).pdAuth.toSeqNo) \land \\ \t1
            (\forall pd : fromInEpr @ \disjoint \langle \{ val~pd, ack~pd \} , ether \rangle) \land \\ \t1
            (\forall pd : PayDetails @ (req~pd \in ether \land ack~pd \notin ether~)
                \iff (pd \in toInEpv \cup toLogged)) \\ \t1
            \land (\forall pd : PayDetails | val~pd \in ether \land pd \in toInEpv @ \\ %
                \t3 pd \in fromInEpa \cup fromLogged) \land \\ \t1
            (\forall pd : fromInEpa \cup fromLogged @  req~pd \in ether) \land
            (toLogged \in \finset PayDetails) \land \\ \t1
            (\forall pd : exceptionLogResult\inv \limg ether \rimg @ pd \in allLogs) \land \\ \t1
            (\forall pds : \power_1 PayDetails; name : NAMES | \\ %
                    \t3 exceptionLogClear(name, image~pds) \in ether @ \\ %
                \t4 \{name\} \cross pds \subseteq archive) \land \\ \t1
            (\forall pd: fromLogged \cup toLogged @ req~pd \in ether)
\end{theorem}~\end{LNewLemma}


\section{Framing schema}\label{ch5.phibop}

We could have used $\Phi BOp$, but this creates a naming compatibility
between the \zeves\ GUI and \zeves\ x-emacs interfaces.
%
\begin{LSDef}[Between world promotion schema]
\begin{schema}{PhiBOp}
  \Delta BetweenWorld
  \\    \Delta ConPurse
  \\    m?,m! : MESSAGE
  \\    name? : NAMES
  \where
  m? \in ether
  \also
  name? \in \dom~conAuthPurse
  \\    \theta ConPurse = conAuthPurse~name?
  \also
  conAuthPurse' = conAuthPurse \oplus \{ name? \mapsto \theta ConPurse~' \}
  \also
  archive' = archive
  \also
  ether' = ether \cup \{ m! \}
\end{schema}~\end{LSDef}

\section{$Ignore$, $Increase$ and $Abort$}\label{ch5.ignore.increase.abort}

\begin{LSDef}[Between world ignore operation]
\begin{zed}
  Ignore ~~\defs~~ [~ \Xi BetweenWorld; name?: NAMES; m?, m! : MESSAGE | m! = \bot ~]
\end{zed}~\end{LSDef}

\begin{LSDef}[Between world increase operation]
\begin{zed}
  Increase ~~\defs~~ Ignore
  \\ \t2                \lor (~\exists \Delta ConPurse @
  PhiBOp \land IncreasePurseOkay ~)
\end{zed}~\end{LSDef}

\begin{LSDef}[Between world abort operation]
\begin{zed}
  Abort ~~\defs~~ Ignore
  \\ \t2                \lor (~\exists \Delta ConPurse @
  AbortPurseOkay \land [~ PhiBOp | m! = \bot ~]~)
\end{zed}~\end{LSDef}

\section{Promoted operations}\label{ch5.promoted}

\subsection{Value transfer operations}\label{ch5.promoted.valuetransfer}

\begin{LSDef}[Between world value transfer $startFrom$ complete operation]
\begin{zed}
  StartFrom ~~\defs~~ Ignore
  \\ \t2                \lor Abort
  \\ \t2                \lor (~ \exists \Delta ConPurse @
  PhiBOp \land StartFromPurseOkay ~)
\end{zed}~\end{LSDef}

\begin{LSDef}[Between world value transfer $startTo$ complete operation]
\begin{zed}
  StartTo ~~\defs~~ Ignore
  \\ \t2                \lor Abort
  \\ \t2                \lor (~ \exists \Delta ConPurse @
  PhiBOp \land StartToPurseOkay ~)
\end{zed}~\end{LSDef}

The next two operations are used in lemmas from Section~\ref{ch14.between-special}.
%
\begin{LSDef}[Promoted $StartFrom$ without $Ignore$ and $Abort$]
\begin{zed}
  StartFromEafromOkay ~~\defs~~ \exists \Delta ConPurse @
  \\ \t3                        PhiBOp \land StartFromPurseEafromOkay
\end{zed}~\end{LSDef}

\begin{LSDef}[Promoted $StartTo$ without $Ignore$ and $Abort$]
\begin{zed}
  StartToEafromOkay ~~\defs~~ \exists \Delta ConPurse @
  \\ \t3                        PhiBOp \land StartToPurseEafromOkay
\end{zed}~\end{LSDef}

\begin{LSDef}[Between world value transfer request operation]
\begin{zed}
  Req ~~\defs~~ Ignore \lor (~ \exists \Delta ConPurse @
  PhiBOp \land ReqPurseOkay ~)
\end{zed}~\end{LSDef}

\begin{LSDef}[Between world value transfer value operation]
\begin{zed}
  Val ~~\defs~~ Ignore \lor (~ \exists \Delta ConPurse  @
  PhiBOp \land ValPurseOkay ~)
\end{zed}~\end{LSDef}

\begin{LSDef}[Between world value transfer acknowledgement operation]
\begin{zed}
  Ack ~~\defs~~ Ignore \lor (~ \exists \Delta ConPurse @
  PhiBOp \land AckPurseOkay ~)
\end{zed}~\end{LSDef}

\subsection{Exception log operations}\label{ch5.promoted.exception}

\begin{LSDef}[Between world read exception log complete operation]
\begin{zed}
  ReadExceptionLog ~~\defs~~ Ignore
  \\ \t2                \lor (~ \exists \Delta ConPurse @
  PhiBOp \land ReadExceptionLogPurseOkay ~)
\end{zed}~\end{LSDef}

Why considers abort twice?
%
\begin{LSDef}[Between world clear exception log complete operation]
\begin{zed}
  ClearExceptionLog ~~\defs~~ Ignore
  \\ \t2                \lor Abort
  \\ \t2                \lor (~ \exists \Delta ConPurse @
  PhiBOp \land ClearExceptionLogPurseOkay ~)
\end{zed}~\end{LSDef}

The next two operations are used in lemmas from Section~\ref{ch14.between-special}.
%
\begin{LSDef}[Promoted $ReadExceptionLog$ without $Ignore$ and $Abort$]
\begin{zed}
  ReadExceptionLogEafromOkay ~~\defs~~ \exists \Delta ConPurse @
  \\ \t3                        PhiBOp \land ReadExceptionLogPurseEafromOkay
\end{zed}~\end{LSDef}

\begin{LSDef}[Promoted $ClearExceptionLog$ without $Ignore$ and $Abort$]
\begin{zed}
  ClearExceptionLogEafromOkay ~~\defs~~ \exists \Delta ConPurse @
  \\ \t3                        PhiBOp \land ClearExceptionLogPurseEafromOkay
\end{zed}~\end{LSDef}

\section{Operations at the world level only}\label{ch5.worldop}

\subsection{Exception Log clear authorisation}

\begin{LSDef}[Between world authorised exception log clear operation]
\begin{schema}{AuthoriseExLogClearOkay}
  \Delta BetweenWorld
  \\    m?, m!: MESSAGE
  \\    name? : NAMES
  \where
  conAuthPurse' = conAuthPurse
  \also
  \exists pds : \power_1 PayDetails @
  \\ \t1                \{ name? \} \cross pds \subseteq archive
  \\ \t1                \land m! = exceptionLogClear (name?, image~ pds)
  \also
  ether' = ether \cup \{ m! \}
  \also
  archive = archive'
\end{schema}~\end{LSDef}

\begin{LSDef}[Authorised between world log clear operation]
\begin{zed}
  AuthoriseExLogClear ~~\defs~~ Ignore \lor AuthoriseExLogClearOkay
\end{zed}~\end{LSDef}

\begin{LSDef}[Between world exception log archiving operation]
\begin{schema}{Archive}
  \Delta BetweenWorld
  \\    m?, m!: MESSAGE
  \\    name? : NAMES
  \where
  conAuthPurse' = conAuthPurse
  \\    ether' = ether
  \also
  archive \subseteq
  \\ \t1                archive' \subseteq
  \\ \t2                archive \cup \{~ log: NAMES \cross PayDetails |
  \\ \t4                                exceptionLogResult~log \in ether ~\}
  \also
  m! = \bot
\end{schema}~\end{LSDef}

\section{The complete protocol}

\begin{LSDef}[Complete transfer protocol between concrete levels]
\begin{zed}
   CompleteProtocol ~~\defs~~ StartFrom \semi StartTo \semi Req \semi Val \semi Ack
\end{zed}~\end{LSDef}

\newpage
\section{Summary}\label{ch5.summary}

\ldefsummary %
\lthmsummary %
\lthmaddeddefsummary %
\lthmaddedthmsummary %
\lzevessummary
%\lpscriptsummary
