<?xml version="1.0" encoding="UTF-8"?>
<!-- 
  Despite other extensions having xmlns inclusion top-down and some bottom-up,
  the top-down approach (i.e. circus, zpatt, zml) was creating problems for GnAST.
-->
<xs:schema  
  targetNamespace="http://czt.sourceforge.net/circus"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:P="http://czt.sourceforge.net/zpatt"
  xmlns:CIRCUS="http://czt.sourceforge.net/circus"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="0.1">
  <xs:annotation>
    <xs:documentation>
      Copyright 2005, 2006 Leonardo Freitas
      $Id: Circus.xsd 6854 2008-03-26 16:12:22Z leouk $
      
      This XML schema defines XML markup for formal specifications 
      written in Circus, a concurrent language for refinement that
      combines CSP, Z and the refinement calculus.
      More information at <a href="http://www.cs.york.ac.uk/~circus">Circus main web page</a>
      or at <a href="http://www.cs.york.ac.uk/~leo">the author'ss web page</a>.
      
      This file is part of the Community Z Tools (CZT) project.
      
      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.
      
      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
      
      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.circus.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="Circus">
        <gnast:package name="net.sourceforge.czt.circus">
          <gnast:package id="ast" name="ast">
            <gnast:generate id="factory" class="CircusFactory" template="CoreFactory.vm"/>
            <gnast:javadoc>
              &lt;p&gt;
              These interfaces represent the AST for Circus. 
              &lt;/p&gt;
            </gnast:javadoc>
          </gnast:package>
          <gnast:package id="impl" name="impl">
            <gnast:generate id="factoryImpl" class="CircusFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor">
            <gnast:generate id="AstVisitor" class="CircusVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <!-- NOT YET...
          <gnast:package id="util" name="util">
            <gnast:generate id="flyFactory" class="FlyweightFactory"
              template="FlyweightFactory.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="createVisitor" class="CreateVisitor"
              template="CreateVisitor.vm"/>
          </gnast:package>
          -->
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>
  
  <!-- NOTE: GnAST considers the first import only in the SchemaProject build phase,
             so always put ZPattern.xsd first for Circus.xsd (i.e. innermost parent).
   -->
  <xs:import namespace="http://czt.sourceforge.net/zpatt" schemaLocation="ZPattern.xsd"/>  
  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>
  
  <!-- ********************************************************************* -->
  <!-- Definitions of the elements in the order of appearance in the grammar -->
  <!-- ********************************************************************* -->

  <!-- Section level paragraphs -->
  
  <xs:element name="ChannelPara" type="CIRCUS:ChannelPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
          A channel paragraph that declares channel names with corresponding types, possibly generic. 
          Channels are used in process definitions. Strokes are not allowed in channel names, and this is
          ensured by the parser. 
        </p>
        <p>
          It represents the <b>channel</b> <code>ChannelDecl</code> grammar rule.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ChannelSetPara" type="CIRCUS:ChannelSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
          A channel set paragraph that declares a name for a channel set.
          A channel set encapsulates a Z <code>Expr</code>.
        </p>
        <p>
          It represents the <b>channelset</b> <code>N == CSExpression</code> grammar rule, 
          where <code>N</code> is a <code>Name</code>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessPara" type="CIRCUS:ProcessPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
          A process paragraph that introduces a name for a process definition.
          Strokes are not allowed in process names, and this is ensured by the parser.
        </p>
        <p>
          This element represents the <b>ProcessDeclaration</b> grammar rule.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CircusConjPara" type="CIRCUS:CircusConjPara" substitutionGroup="Z:Para" abstract="true">
    <xs:annotation>
      <xs:documentation>
        A (generic) Circus conjecture paragraph. It is used by tools to ensure that
        certain special properties hold.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="TransformerPara" type="CIRCUS:TransformerPara" substitutionGroup="CIRCUS:CircusConjPara">
    <xs:annotation>
      <xs:documentation>
        A circus conjecture between two circus transformer predicates.
        This is usually used by the model checker as a refinement transformation
        between process and actions, but can also be used as a simulation or 
        equivalence transformation by other tools.
      </xs:documentation>
    </xs:annotation>        
  </xs:element>  
  
  <!-- Section level declarations -->  
  <!-- Channel declaration -->
  
  <xs:element name="ChannelDecl" type="CIRCUS:ChannelDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        <p>
          A channel declaration is a Z declaration that accepts generic types.
          It represents the <b>SimpleCDeclaration</b> grammar rule.
        </p>
        <p>
          Channels can be declared either as typed or synchronisation. 
          They can als have generic types or come from a previously declared schema.
        </p>
        <p>
          The structure of the complex type associated with this class is a follows:
          <ul>
            <li>Typed  channels = optional generics, nonempty list of declnames, non-null Expr. </li>
            <li>Synch. channels = empty generics, nonempty list of declnames, RefExpr(SYNCH), where SYNCH is a given type. </li>
            <li>Schema channels = optional generics, empty list of declnames, non-null RefExpr. </li>          
          </ul>
          This invariant is to be enforced by the parser, and further unfolded by the typechecker.
          That is, channels declared through schemas must be expanded to their typed declaration form.
          Such unfolding must take into account both sets of generic formals comming from the channel 
          declaration as well as the schema generic formals. In this sense, the user is allowed to
          change the pattern of generic formals inside the schema through the generic formals of the
          channel declaration (see <code>./parser/tests/cirus/channels.tex</code> for an example).
        </p>
        <p>
          The <code>getNameList()</code> method contains a list of non-null <code>NameList </code> 
          objects with size two. The first element is the (possibly empty) list of generic formal 
          parameters, whereas the second element is the (possibly empty) list of declared channel names.
          If the second list is empty, that means the <code>ChannelDecl</code> represents a <em>channelfrom</em>
          (i.e., channel declaration from a schema expression found in the <code>getExpr()</code> method).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Channel Set Expressions -->
  <xs:element name="ChannelSet" type="CIRCUS:ChannelSet" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
          Abstract base classe for Circus channel set expressions. There are two
          implementations: one for normal <code>CircusChannelSet</code>s appearing
          in specifications; and one for chennel set jokers appearing in refinement
          laws.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="CircusChannelSet" type="CIRCUS:CircusChannelSet" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        <p>
          An channel set expression is a special kind of expression used in Circus that is
          not within the Z expressions subtree. It represents the <b>CSExpression</b> grammar rule.
        </p>
        <p>
          Although it is formed by a Z expression, channel set expressions cannot appear wherever a Z expression can;
          they are only allowed in some operators such parallelism and hiding. For this it encpasulates a Z expression
          within the <code>ChannelSet</code> class.
        </p>
        <p>
          The most common Z expressions used in channel sets are set extensions, the empty set, and application expressions.
          The most common application expressions are set union, intersection, and diference. Other (possibly user defined) 
          functions can also be used.
        </p>
        <p>
          In any case, a channel set expression is well-typed only if the names it refer to are from previously declared channels,
          or a previously declared channel set. That is, a well-typed <code>ChannelSet</code> must be a power type of previously declared
          channel names.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="BasicChannelSetExpr" type="CIRCUS:BasicChannelSetExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        <p>
          A channel set expression containing a set of references to previously declared channel names (i.e. channel references).
          It represents the grammar rules for empty and enumerated channel sets. It is just like a set extension but the parser
          identifies differently due to the spceial channel set braces.        
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Description -->                
  <!-- DESIGN DECISION
      In order to allow a more uniform implementation, we avoided having an explicit ProcessDesc hierarchy tree.
      Instead, we expect the parser to actually manage the appropriate creation, hence allowing productions such as:      
      (x: \nat @ c \then STOP) \extchoice (y: \nat @ d \then STOP).
      
      This decision allows one to have a uniform/intuitive implementation of Declaration::Unary processes as expected. 
      That is, ParamProcessDesc and IndexedProcessDesc are considered unary as well.

  <xs:element name="ProcessDesc" type="CIRCUS:ProcessDesc" abstract="true">
      <xs:annotation>
          <xs:documentation>
              An abstract process description.
              Available extensions process definition, parameterised process, and indexed process.
          </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="ParamProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ProcessDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IndexedProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ProcessDesc">
    <xs:annotation>
      <xs:documentation>
        An indexed process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
  -->

  <!-- Processes -->    
  <xs:element name="CircusProcess" type="CIRCUS:CircusProcess" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
          An abstract Circus process definition. It represents the <b>ProcessDefinition</b> grammar rule.
          Available extensions are basic process description; recursion; prefixing; guarded process; 
          process call; all forms of unary, binary, iterated, and indexed processes;
          processes involving expressions; and processes involving declarations. 
        </p>
        <p>
          The parser is responsible to enforce restrictions over process definitions involving parameters 
          or indexes within some binary productions. For instance, the parse must rule out cases such as 
          <code>(x: nat @ A) [] (y: nat @ B)</code>, since parameterised process can only appear in an 
          external choice whenever the actual parameters are given.
        </p>
        <p>        
          This allows us to represent the grammar rules <b>ProcessDefinition</b> and <b>Process</b> with 
          a single class. The main advantage is that we can treat unary process definitions uniformly 
          through a single hierarchy tree.
        </p>
        <p>
          Naming this class <code>Process</code> would have been a better choice but unfortunately this would 
          conflict with the interface <code>java.lang.Process</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Process1" type="CIRCUS:Process1" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract unary Circus process.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="Process2" type="CIRCUS:Process2" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract binary Circus process.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessD" type="CIRCUS:ProcessD" abstract="true" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract unary Circus process with Z declarations.</p>
        <p>The parser must enforce that the declared variables do not have strokes via <code>VarDecl</code>,
          that strokes should be ignored via <code>InclDecl</code> (schema inclusion), and that <code>ConstDecl</code>
        is not allowed at all.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessIte" type="CIRCUS:ProcessIte" abstract="true" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract iterated Circus process with Z declarations.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <!-- DESIGN DECISION:
    Originally the substitution group for ProcessIdx was ProcessD, hence the two subtrees for iterated and
    indexed iterated processes were siblings. However, yet replicated and iterated processes are not simply 
    syntactic sugar due to the special renaming that changes the channel types, one can see it as a replication 
    followed by a kind of renaming. Therefore, by deriving from ProcessIte instead of ProcessD, we give the user 
    the chance to reuse visiting code for replication and then further add the necessary renaming functionality. 
    If, on the other hand, a different treatment of replication becomes necessary, one just needs to ignore the 
    superclass implementation from ProcessIte and provide a new one for the replication task.
  -->
  <xs:element name="ProcessIdx" type="CIRCUS:ProcessIdx" abstract="true" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract indexed and iterated Circus process with Z declarations.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process :: Unary with Declaration -->
  <xs:element name="ParamProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        <p>
          A parameterised process definition. It represents grammar rule <b>Declaration @ ProcessDefinition</b>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IndexedProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        An indexed process definition. It represents grammar rule <b>Declaration odot ProcessDefinition</b>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>     
  
  <!-- Process :: Basic -->

  <xs:element name="BasicProcess" type="CIRCUS:BasicProcess" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>
          A process definition for an explicit process declaration.
          It is formed by a (possibly empty) set of process paragraphs,
          an optional process state given as a schema and a (mandatory) 
          main action definition.
        </p>
        <p>
          It represents the grammar rule <b>begin</b> <code>PParagraph*</code> <b>state</b> <code>Schema-Exp PParagraph*</code>
          <b>@</b> <code>Action</code> <b>end</b>.
        </p>
        <p>
          For the process state, the corresponding action (as a SchExprAction) or Z paragraph (as a Schema or HorizontalDef) 
          must contain a <code>CircusStateAnn</code> annotation.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process :: Call -->

  <!-- DESIGN DECISION: 
  
    As Circus allows calls over definitions given on-the-fly, we need a more powerful approach for a call,
    rather than a simple Name. There are two approaches for the implementation of process/action calls.
    We have taken the first one in order to simplify the implementation of visitor of different tools.
    
    The first demands specialised CallUsage attribute on CallProcess, whereas the second introduces specialised classes      
    for each special production. For processes, these are actual parameters, indexes, and actual types. For action 
    these are actual parameters, and command parameters.
    
    Another interesting issue is that in the production tree, one is allowed to use a Process for renaming 
    (Process[N^+ := N^+]).  This allowed the definition of renaming on-the-fly (unnamed) or via a call processes.                                                
    Ex:  (c?x \then Skip)[c := b] or P = (c?x \then Skip), Q = P[c := b].
    On the second case via CallProcess it means that the CircusProcess descendent of ProcessDesc is being selected.
    In turn, the kind of CircusProcess is CallProcess and the list of renaming names are under RenameProcess.
    This allows both indexed and parameterised processes to use renaming hence creating a undesired ambiguity.
    
    The second approach is to have individual classes for this on-the-fly declaration and call directly,
    together with a base case of call with simple name on it. See more details below at ActualParamProcess.     
  -->
  <xs:element name="CallProcess" type="CIRCUS:CallProcess" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>
          Circus process reference call. In other words, it permits a name to be a process.
          That is, it contains a reference name to lookup the process definition.
        </p>
        <p>
          Moreover, it contains two list of expressions and an attribute defining the kind of call this 
          reference is related too. The first list is related to generic actuals, whereas the second list is 
          related to actual parameters or indexes. 
          An empty list of generic actuals means that refering process is not generic.
          An empty list of expressions means a simple process call of the grammar rules <b>N, N[Expr+]</b>,
          where <b>N</b> is the process name.
          If the list of expressions is not empty, then the <code>CallUsage</code> attribute defines if this is an indexed 
          process instantiation call, a parameterised process call.
          It represents the grammar rules: <b>N(Expr+), N lfloor Expr+ rfloor</b>
        </p>
        <p>        
          The invariant is as follows:  TODO: THIS COMMENT NEEDS UPDATE (See Parser.xml)
          <ul>
            <li>N        = nonempty name, empty generic actuals, and empty parameters/indexes. </li>
            <li>N[Expr+] = nonempty name, nonempty generic actuals, and empty parameters/indexes. </li>
            <li>N(Expr+) = empty generic actuals, nonempty parameters. 
              Internal name for on-the-fly, user given name for previously declared action. 
            The call type defines whether the expressions are actual parameters or indexes.</li>
            <li>N[Expr+](Expr+) = nonempty generic actuals, nonempty parameters. 
              Internal name for on-the-fly, user given name for previously declared action. 
            The call type defines whether the expressions are actual parameters or indexes.</li>          
          </ul>
          The case for parameterised and indexed process is not present in the grammar. 
          The default value of CallUsage is <b>Param</b> and need to be inspected only for the case where the 
          second expression list demands attention.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process :: Unary  -->  
  <xs:element name="HideProcess" type="CIRCUS:HideProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with event concealment through hiding.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RenameProcess" type="CIRCUS:RenameProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with channel renaming. As channels in Circus are strongly-typed, type-checking is expected.
        Note that, since the class derives from <code>Process1</code>, the grammar does not accept on-the-fly renaming 
        of parameterised processes. ex: (x: \nat @ c!x -> Stop)[c := b]. This is a design decision for uniformity purposes only.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="AssignmentPairs" type="CIRCUS:AssignmentPairs">
    <xs:annotation>
      <xs:documentation>
        Encapsulates two lists used for assignments.
        <p>
          Syntactically, that corresponds to either channels in <code>RenamingProcess</code>,
          or to variables in an assignment command. Semantically, it is also used to determine
          which (process) state variables were updated, and in which order.
        </p>
        <p>
          It represents two lists of equal size for the left and right hand sides. 
          Moreover, for <code>RenamingProcess</code>, the RHS list can only contain 
          <code>RefExpr</code>, as channels might have generic actuals.
          For state updates, the RHS may be a predicate, in which case it is given as
          an SchExpr to operate upon the process state.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: Binary -->
  <xs:element name="SeqProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcess" type="CIRCUS:ParProcess" substitutionGroup="CIRCUS:Process2" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus process for parallel operators.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcess" type="CIRCUS:ParProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus process for interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcess" type="CIRCUS:ParallelProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus process for parallel composition;
        it includes the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelProcess" type="CIRCUS:AlphabetisedParallelProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus alphabetised parallel process; it includes the two alphabets as channel sets.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: Expressions -->

  <!--
    DESIGN DECISION: 
      The next element was used for on-the-fly declaration of parameters for processes. 
      A similar construction needed to be created for indexes, and actual types. 
      Actions and commands also have similar constructs.
      
      These constructs usually appear through refinement steps from tools rather than directly by the user.           
      As the treatment of each of these cases is very similar, having separate AST nodes would possibly mean 
      repeated code (versioning and maintenance problems). 
      
      Instead, as the treatment of each of these cases is equivalent to a CallProcess with the appropriate call 
      type determining the meaning of the list of expressions, we assume that the Circus parser will interpret
      these cases appropriately by generating internal ProcessPara on-the-fly with reserved names not allowed to
      be declared by the user.

  <xs:element name="ProcessE" type="CIRCUS:ProcessE" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        An abstract Circus process involving expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
    <xs:element name="ActualParamProcess" type="CIRCUS:ActualParamProcess" substitutionGroup="CIRCUS:ProcessE">
      <xs:annotation>
        <xs:documentation>
          Defines a parameterised Circus process on-the-fly with its actual parameter.
          This enables on-the-fly declaration of parameterised indexed processes.             
          Ex: (x: T \spot c.x \then Skip)~(0) \equiv c.0 \then Skip.
          Note that this is different from a parameterised process description with a reference name calling 
          it with the given actual parameters.
          Ex: P = (x: T \spot c.x \then Skip).
                  Q = P~(0).
        </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="InstantiationProcess" type="CIRCUS:InstantiationProcess" substitutionGroup="CIRCUS:ProcessE">
    <xs:annotation>
      <xs:documentation>
        Defines a indexed Circus process on-the-fly with its actual instantiation
        This enables on-the-fly declaration of indexed parameterised processes.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->

  <!-- Process Definition :: Unary :: Declaration :: Iterated -->
  <xs:element name="SeqProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcessIte" type="CIRCUS:ParProcessIte" substitutionGroup="CIRCUS:ProcessIte" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus iterated parallel process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcessIte" type="CIRCUS:ParProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessIte" type="CIRCUS:ParallelProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="AlphabetisedParallelProcessIte" type="CIRCUS:ParallelProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for alphabetised iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: Unary :: Declaration :: Iterated :: Indexed -->
  <xs:element name="SeqProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="IntChoiceProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcessIdx" type="CIRCUS:ParProcessIdx" substitutionGroup="CIRCUS:ProcessIdx" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus indexed iterated parallel process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="InterleaveProcessIdx" type="CIRCUS:ParProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessIdx" type="CIRCUS:ParallelProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelProcessIdx" type="CIRCUS:ParallelProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for alphabetised indexed and iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Action Para -->
  <xs:element name="ActionPara" type="CIRCUS:ActionPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
          A action paragraph that declares a name for an action definition.
          Strokes are not allowed in channel set names, and this is ensured by the parser.
        </p>
        <p>
          This element represents the <code>N == ParAction</code> grammar rule, where,
          where <code>N</code> is a <code>Name</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Name Set Paragraphs -->
  <xs:element name="NameSetPara" type="CIRCUS:NameSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>        
        <p>
          A name set paragraph that introduces a name for a name set.
          A name set encapsulates a Z <code>Expr</code>.
        </p>
        <p>
          It represents the <b>nameset</b> <code>N == NSExpression</code> grammar rule, 
          where <code>N</code> is a <code>Name</code>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Name Set Expressions -->
  <xs:element name="NameSet" type="CIRCUS:NameSet" abstract="true">
    <xs:annotation>
      <xs:documentation>        
        <p>
          Abstract base classe for Circus name set expressions. There are two
          implementations: one for <code>CircusNameSet</code>s appearing
          in specifications; and one for name set jokers appearing in refinement
          laws.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CircusNameSet" type="CIRCUS:CircusNameSet" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>        
        <p>
          A name set expression is a special kind of expression used in Circus that is
          not within the Z expressions subtree. It represents the <b>NSExpression</b> grammar rule.
        </p>
        <p>
          Although it is formed by a Z expression, name set expressions cannot appear wherever a Z expression can;
          they are only allowed in some operators such as parallelism. For this it encpasulates a Z expression
          within the <code>NameSet</code> class.
        </p>
        <p>
          The most common Z expressions used in name sets are set extensions, the empty set, and application expressions.
          The most common application expressions are set union, intersection, and diference. Other (possibly user defined) 
          functions can also be used.
        </p>
        <p>
          In any case, a name set expression is well-typed only if the names it refer to are from previously declared state variables,
          or a previously declared name set. That is, a well-typed <code>NameSet</code> must be a power type of previously declared
          state variable names.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Action Description -->     
  <!-- See ProcessDesc above 
  <xs:element name="ActionDesc" type="CIRCUS:ActionDesc" abstract="true">
      <xs:annotation>
          <xs:documentation>
              An abstract action description.
              Available extensions action definition, and parameterised action.
          </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="ParamActionDesc" type="CIRCUS:ParamActionDesc" substitutionGroup="CIRCUS:ActionDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised action description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->
  
  <!-- Actions -->    
  <xs:element name="CircusAction" type="CIRCUS:CircusAction" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
          An abstract Circus action definition. It represents the <b>ParAction</b> grammar rule.
          Available extensions are recursion; prefixing; guarded actions; action call; 
          all forms of unary, binary, iterated, and indexed actions;
          actions involving expressions; and actions involving declarations. 
        </p>
        <p>
          The parser is responsible to enforce restrictions over action definitions involving parameters 
          within some binary productions. For instance, the parse must rule out cases such as 
          <code>(x: nat @ A) [] (y: nat @ B)</code>, since parameterised actions can only appear in an 
          external choice whenever the actual parameters are given.
        </p>
        <p>        
          This allows us to represent the grammar rules <b>ParAction</b>, <b>Action</b>, and <b>CSPAction</b>
          with a single class. The main advantage is that we can treat unary action definitions uniformly 
          through a single hierarchy tree.
        </p>
        <p>
          Naming this class <code>Action</code> would have been a better choice but it often conflicts with 
          other main stream Java libraries class names.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Action1" type="CIRCUS:Action1" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        An abstract unary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="Action2" type="CIRCUS:Action2" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        An abstract binary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="ActionD" type="CIRCUS:ActionD" abstract="true" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>
          An abstract unary Circus action with Z declarations.
        </p>
        <p>
          The parser must enforce that the declared variables do not have strokes via <code>VarDecl</code>,
          that strokes should be ignored via <code>InclDecl</code> (schema inclusion), and that <code>ConstDecl</code>
          is not allowed at all.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="ActionIte" type="CIRCUS:ActionIte" abstract="true" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        An abstract iterated unary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Action :: Unary with Declaration -->
  <xs:element name="ParamAction" type="CIRCUS:ActionD" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        A parameterised action definition. It represents grammar rule <b>Declaration @ ParAction</b>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Action :: Commands (base class) -->
  <xs:element name="CircusCommand" type="CIRCUS:CircusCommand" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
          An abstract command action definition. Available extensions are specification statement
          in Carroll Morgan's style; (possibly multiple) assignment; if guards in Dijkstra's style;
          (possibly multiple) variable declaration; and parameterised commands with qualified declarations.
        </p>
        <p>It represents the grammar rule <b>ParCommand</b> as the base class of Circus commands.</p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  
  <!-- Action :: Schema-Exp -->  
    
  <xs:element name="SchExprAction" type="CIRCUS:SchExprAction" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
          An action given as a schema expression.
          In this way, schema expressions are included into the <code>CircusAction</code> subtree
          in a similar way as schema expressions are included in the declaration and predicate subtrees.
        </p>
        <p>
          As one might use a schema expression for defining a Z schema (i.e. S and T), this class contains an 
          Z <code>Expr</code> instead of <code>SchExpr</code>. The parser is responsible to rule out other 
          possibilities and ensure that only well formed schema expressions are allowed.
          From the CZT these came through <code>SchExpr</code>, <code>SchExpr2</code>, <code>DecorExpr</code>,
          <code>NegExpr</code>, and <code>RenameExpr</code>. (TODO: Check this carefully).
        </p>        
        <p>
          For the process state, this action or a the corresponding Z paragraph must contain a <code>CircusStateAnn</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <!-- Action :: Call -->  
  <xs:element name="CallAction" type="CIRCUS:CallAction" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
          Circus action reference call. In other words, it permits a name to be an action.
          That is, it contains a reference name to lookup the action definition.
        </p>
        <p>
          Moreover, it contains a list of expressions representing possible actual parameters.
          An empty list of expressions means a simple action call of the grammar rule <b>N</b>,
          where <b>N</b> is the action name.
          If the list of expressions is not empty, then the this is a parameterised action.
          It represents the grammar rule <b>N(Expr+)</b> for CSP actions and commands.
        </p>
        <p>
          The invariant is as follows:        
          <ul>
            <li>N        = nonempty name and empty parameters. </li>
            <li>N(Expr+) = nonempty parameters. Internal name for on-the-fly, user given name for previously declared action. </li>
          </ul>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- CSP Action :: ActionDesc -->
    
  <!-- 
    <xs:element name="ActualParamAction" type="CIRCUS:ActualParamAction" substitutionGroup="CIRCUS:CircusAction">
      <xs:annotation>
        <xs:documentation>
          The CSP operator for parameterised action defined on the fly with its actual parameters.
          Ex: (x: \nat \spot c.x \then Skip)(10)
        </xs:documentation>
      </xs:annotation>
    </xs:element>
    -->

  <!-- CSP Action :: Basic -->      
  <xs:element name="BasicAction" type="CIRCUS:BasicAction" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract class for basic Circus action.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SkipAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
          Circus action that represents successful silent termination. That is, an action that has 
          terminated (i.e. ok' = true and wait' = false) and no modification in the trace has 
          occurred (i.e. trace' = trace).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="StopAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
          Circus action that represents deadlock. That is, an action that refuses every possible event
          and is still waiting (i.e. wait' = false).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChaosAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
          Chaotic Circus action as defined by the UTP (see also Hoare's CSP CHAOS process, 
          as well as Roscoe's CSP <b>div</b> process).
        </p>
        <p>
          Theoretically, it represents the bottom element of the Circus lattice of 
          failures-divergences with embedded imperative features. 
          Implementations should usually treat this element as the base case for the 
          <b>possibility</b> (not certainty) of divergence.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- CSP Action :: Unary -->  
  <xs:element name="MuAction" type="CIRCUS:MuAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>The mu operator defines a recursive action.</p>
        <p>The parser must enforce that the given name does not have strokes.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GuardedAction" type="CIRCUS:GuardedAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus guarded action defines an action guarded by a Z predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="HideAction" type="CIRCUS:HideAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus hide operator defines events concealment within an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PrefixingAction" type="CIRCUS:PrefixingAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus operator for actions prefixed with a communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SubstitutionAction" type="CIRCUS:SubstitutionAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>
          Circus action variable substitution. As variables in Circus are strongly-typed, type-checking is expected here.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <!-- CSP Action :: Binary -->
  <xs:element name="SeqAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Sequential composition between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        External choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Internal choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParAction" type="CIRCUS:ParAction" abstract="true" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        <p>
          An abstract parallel action definition;
          it includes the name set partitions of the state.
        </p>
        <p>
          As empty name disjoint sets are often used in parallel actions, syntactic sugar for these cases
          is provided in the grammar rules for interleaving, parallel composition, and alphabetised parallel 
          composition, so that we do not need explicit AST classes. 
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveAction" type="CIRCUS:ParAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        <p>
          Interleaving between two actions.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelAction" type="CIRCUS:ParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Parallel composition between two actions;
        it includes the channel set expression for the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelAction" type="CIRCUS:AlphabetisedParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Alphabetised Parallel composition between two actions;
        it includes the channel set expression for both alphabets as synchronisation sets.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- CSP Action :: Unary :: Declaration :: Iterated -->
  <xs:element name="SeqActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParActionIte" type="CIRCUS:ParActionIte" abstract="true" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        <p>
          An abstract parallel iterated action definition.
          it includes the name set partitions of the state.
        </p>
        <p>
          As empty name disjoint sets are often used in iterated parallel actions, syntactic sugar for these cases
          is provided in the grammar rules for iterated interleaving, iterated parallel composition, and iterated 
          alphabetised parallel composition, so that we do not need explicit AST classes. 
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveActionIte" type="CIRCUS:ParActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelActionIte" type="CIRCUS:ParallelActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelActionIte" type="CIRCUS:ParallelActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for alphabetised iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Communication --> 
  <xs:element name="Communication" type="CIRCUS:Communication">
    <xs:annotation>
      <xs:documentation>
        <p>
          A CSP communication that is part of a prefixing process or action. 
          If the communicating channel has been declared with generic types, the communication 
          must carry the generic actual expressions, hence we have a <code>RefExpr</code> rather than
          a <code>Name</code>. It represents the <b>Communication</b> grammar rule.
        </p>
        <p>
          A communication can be either a communication for synchronisation, input, output, or mixed.
          A communication can also appear in a channel set expression, in which case no fields are allowed.
          Synchronisation has no fields. Input and Output has only input or output fields respectively. 
          Mixed communication has both input and output fields, such as <code>c?x:P!v -> A</code>.
        </p>
        <p>
          The semantics of dot (c.x) and output (c!x) is equivalent. 
          However, for some applications/tools, their evaluation can be done differently.
          Except for references (without generics) and numerals, expressions MUST be 
          surrounded by parenthesis. Similarly, predicates on input prefix restrictions
          must also be surrounded by parenthesis.
        </p>
        <p>
          Communications are annotated by the type checker with a CommunicationType, which
          includes the declared channel name/type pair, as well as the communication pattern
          signature. This is useful because the communication pattern type might not necessarily
          be the same as the type of the channel. Also, we mark the channel within the communication 
          as a generic, indexed or normal channel.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Communication Fields --> 
  <xs:element name="Field" type="CIRCUS:Field" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
          An abstract field is part of a communication. 
          Available extensions are input, dot, and output fields.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InputField" type="CIRCUS:InputField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        <p>
          An input field that is part of a communication.
          It represents grammar rules <b>?N</b> and <b>?N: Pred</b>.
        </p>
        <p>
          The parse must ensure that the declared name <b>N</b> does not have strokes.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DotField" type="CIRCUS:DotField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        <p>
          A field that is part of a communication and contains an expression.
          It represents the grammar rule <b>.Expr</b>.
        </p>
        <p>
          In general, the ``dot'' is treated as output communication.
          However, depending on the purpose of use, it can be considered as a reading or writing synchronisation point.        
        </p>
        <p>        
          Another example where the differentiation between dot and output fields is relevant comes from CSP_M and FDR,
          where ``dot'' fields are used for resolved expressions, whereas ``output'' fields can be used for expressions 
          yet to be resolved. 
          Roscoe's give some insight on further interesting possibilities that motivates such differentiation in 
          his CSP book (p.27).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Circus declarations -->  
  <xs:element name="QualifiedDecl" type="CIRCUS:QualifiedDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        This is like <code>VarDecl</code>, but it includes qualifier attributes for each <code>Name</code>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
  
  <!-- Circus Commands -->
  <xs:element name="CircusGuardedCommand" type="CIRCUS:CircusGuardedCommand" abstract="true" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
          Abstract base class for IfGuardedCommand and DoGuardedCommand
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="SpecStmtCommand" type="CIRCUS:SpecStmtCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
          Circus command declaring a specification statement in Carroll Morgan's style.
          It represents the grammar rule <code>N+:[Pred,Pred]</code>.
          The parser is responsible to ensure that no strokes are allowed in the frame variables.
        </p>
        <p>
          As assumption and coercion are syntactic sugar for often used specification statements,
          they do not have an explicit AST class. Instead, assumption (grammar rule <code>{Pred}</code>)
          is represented by a specification statement with empty frame, <code>Pred</code> precondition, 
          and true postcondition. Similarly, coercion (grammar rule <code>[Pred]</code>) is represented by 
          a specification statement with empty frame, true precondition, and <code>Pred</code> postcondition.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AssignmentCommand" type="CIRCUS:AssignmentCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        Circus command declaring (possibly) multiple assignment.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IfGuardedCommand" type="CIRCUS:CircusGuardedCommand" substitutionGroup="CIRCUS:CircusGuardedCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
          Command declaring a if statement containing guarded actions in Dijkstra's style.
          Although semantically different, we can represent the AST for the production of guarded actions 
          from the BNF of if commands with the <code>GuardedAction</code> AST class, hence minimising the 
          AST classes. 
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:element name="DoGuardedCommand" type="CIRCUS:CircusGuardedCommand" substitutionGroup="CIRCUS:CircusGuardedCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
          Command declaring a do (while) statement containing guarded actions in Dijkstra's style.
          Although semantically different, we can represent the AST for the production of guarded actions 
          from the BNF of do commands with the <code>GuardedAction</code> AST class, hence minimising the 
          AST classes. 
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:element name="VarDeclCommand" type="CIRCUS:VarDeclCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
          Command declaring (possibly multiple) variables local to an action definition.
          The parser is responsible to ensure that no strokes are allowed in the frame variables.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Circus predicates -->
  
  <xs:element name="TransformerPred" type="CIRCUS:TransformerPred" 
              substitutionGroup="Z:Pred" abstract="true">
    <xs:annotation>
      <xs:documentation>
        A quantified refinement predicate, where the quantifier is
        universal on the alphabet of the Circus preocess or action.
        For instance, in A \subseteq B, we have that 
        \forall V @ B \implies A.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- DESIGN DECISION:
     An alternative to adding a new predicate class would be to reuse MemPred
     and have the transformation relations as just relational operators defined
     within circuspatt_toolkit.tex (much like what already happens for ZPattern).
     
     The problem for Circus is that neither Action nor Process are expressions,
     as opposed to schemas in ZPattern, hence the need to include Action/Process
     within the Expr subtree if this path were to be followed in CircusPattern.xsd. 
     
     Although regarding the AST this placement choice is somewhat irrelevant, 
     choosing the option with MemPred might unnecessarily complicate the CircusPttern
     parser. Thus, we decided to have them as separate predicates and do not 
     touch/mofidy/extend the Expr tree.
     
     Another benefitial consequence of this choice is that we now do not need
     varied forms of assertion check paragraphs, but just a transformer paragraph
     for any type of transformer predicate!
  -->
  
  <xs:element name="ActionTransformerPred" type="CIRCUS:ActionTransformerPred"
              substitutionGroup="CIRCUS:TransformerPred">
    <xs:annotation>
      <xs:documentation>
        An action transformer predicate is a predicate that relates two actions
        by one of the available transformation relations in one of the available
        models. 
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessTransformerPred" type="CIRCUS:ProcessTransformerPred"
              substitutionGroup="CIRCUS:TransformerPred">
    <xs:annotation>
      <xs:documentation>
        A process transformer predicate is a predicate that relates two process
        by one of the available transformation relations in one of the available
        models. 
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Special Circus actions used on post-parsing. 
       They are related to scope for mutual recursion and variable declaration.
    -->  
  
  <xs:element name="LetAction" type="CIRCUS:LetAction" substitutionGroup="CIRCUS:Action1" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract local environment.
      </xs:documentation>
    </xs:annotation>     
  </xs:element>      
  <xs:element name="LetMuAction" type="CIRCUS:LetMuAction" substitutionGroup="CIRCUS:LetAction">
    <xs:annotation>
      <xs:documentation>
        Local environment for mu actions. It resolves mutual recursions through a weak fixed point
        equation with an array of recursive variables.
      </xs:documentation>
    </xs:annotation>     
  </xs:element>    
  <xs:element name="LetVarAction" type="CIRCUS:LetVarAction" substitutionGroup="CIRCUS:LetAction">
    <xs:annotation>
      <xs:documentation>
        Local environment for prefixing actions involving input fields, parameterised actions, and variable commands.
        They are important to carry the declared type, and any type restrictions, of these constructs. Note thist 
        is different from the signature the referred variable in the let may occur in, as signatures only contain
        maximal types generated by the type checker.
      </xs:documentation>
    </xs:annotation>     
  </xs:element>    
  
  <!-- Additional top-level types in Circus -->
  
  <xs:element name="CircusType" type="CIRCUS:CircusType" abstract="true" 
    substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        An abstract Circus type. It is the base class for all Circus types, 
        and it contains resolved generics - just like Z.Type2.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
  
  <xs:element name="CircusSigType" type="CIRCUS:CircusSigType" abstract="true" 
    substitutionGroup="CIRCUS:CircusType">
    <xs:annotation>
      <xs:documentation>
        An abstract Circus type that contains a signature. 
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
  
  <!-- DESIGN CLARIFICATION:
  
  In Standard Z, the BNF for the type system includes Type, Type2, and Signature. 
  Type represent generic types, which encompass all constructs that allow the
  declaration of (formal) generic parameters, such as generic axiomatic descriptions
  and generic schemas.
  Type2 represent bare types where (formal) generic parameters have been resolved,
  even if the resolution is to a "GENTYPE". 
  Signature contains a list of name type pairs, where the type associated with each 
  name is Type, hence allowing the opportunity for declarations which have (formal)
  generic parameters, such as channel declarations.
  
  For example:
  
  channel [X, Y] c, d: X x Y; e, f: Y 
  
  ChannelPara has a signature containing a generic type should have Type, where [X, Y] 
  are part of GenericType, and the references to X and Y are GENTYPE X/Y. 
  Thus, ChannelType is a Type2 and contains a the type of each names it represents.
  It works similarly to PowerType in Z, as far as type inference is concerned. 
  That is, it contains 
  -->
  <xs:element name="ChannelType" type="CIRCUS:ChannelType" substitutionGroup="CIRCUS:CircusType">
    <xs:annotation>
      <xs:documentation>
        <p>
          A channel type is like a generic type, where the type can be <code>null</code> for synchronisation channels.
          The <code>OptionalType</code> is the resolved type after instantiation via generic actuals or type inference.
        </p>
        <p>
          It contains an underlying base type, which corresponds to the maximal type of the declared channel type.
          One should also look at the CommunicationType, which contains the actual signature of the communication
          related to the channel type. For instance, in a declaration like "channel [X] c: X \cross X", the type
          will be ChannelType(GenericType(List(ZName("X")), ProdType(List(X, X)))).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
  
  <xs:element name="CommunicationType" type="CIRCUS:CircusSigType" substitutionGroup="CIRCUS:CircusSigType">
    <xs:annotation>
      <xs:documentation>
        <p>
          In a declaration like "channel [X] c: X \cross X", the type will be ChannelType(GenericType(List(X), ProdType(List(X, X)))).
          Whenever it is used, a communication involving "c" may have different signatures. For instance, "c!0!2" 
          and "c[\nat]?x". Thus, a communication breaks down the structure to the underlying fields. This is the type for SigmaExpr.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  
  <xs:element name="ChannelSetType" type="CIRCUS:CircusSigType" substitutionGroup="CIRCUS:CircusSigType">
    <xs:annotation>
      <xs:documentation>
        A channel set type contains the signature of the set of names it represents, where synchronisation channels have null type.
        The signature contains the channel name and its corresponding ChannelType. So, synchronisation channels will have 
        in their signature a name with a <code>ChannelType</code> whose <code>getType()==null</code>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="ProcessType" type="CIRCUS:ProcessType" substitutionGroup="CIRCUS:CircusType">
    <xs:annotation>
      <xs:documentation>
        A process type contains its signature.
        Generic process parameters must be resolved.
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  
  <!-- Additional process-level types in Circus -->

  <xs:element name="ActionType" type="CIRCUS:ActionType" substitutionGroup="CIRCUS:CircusType">
    <xs:annotation>
      <xs:documentation>
        An action type contains the action signature.              
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="NameSetType" type="CIRCUS:CircusSigType" substitutionGroup="CIRCUS:CircusSigType">
    <xs:annotation>
      <xs:documentation>
        A name set type contains the signature of the set of names it represents.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="SigmaExpr" type="CIRCUS:SigmaExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        <p>
          Expression for channel selections, such as c.x or c.true for channel c. 
          It is set of pairs, where the first element is the channel reference and 
          the second element is the expression corresponding to the value to be
          communicaticated. The channel reference is a RefExpr, as channel can 
          contain generic actuals. It denotes set of the all the possible values a 
          channel can communicate.
        </p>
        <p>
          These expressions require special typechecking to ensure that elements are 
          well typed with respect to the (RefExpr X Expr) pair, rather than the structure 
          of the expressions. That is, SigmaExpr unify even when the expression have different
          types, so that we can create the Sigma environment.
        </p>
      </xs:documentation>
    </xs:annotation>     
  </xs:element>  
  
  <!-- Additional top-level signatures in Circus -->
  
  <xs:element name="CircusSignature" type="CIRCUS:CircusSignature" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract Circus signature: it contains a name.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="ProcessSignature" type="CIRCUS:ProcessSignature" 
              substitutionGroup="CIRCUS:CircusSignature">
    <xs:annotation>
      <xs:documentation>        
        <p>
          A process signature consists of the process name, possibly empty generic formal parameters, 
          possibly empty formal parameters or indexes, and the channels usage.
          Generic actuals must be resolved while type checking similarly to Z and ObjectZ (see ClassSignature and oz.TypeChecker).
        </p>        
        <p>
          List[SignatureList] getSignatureList(), where SignatureList can be:
            + ZSignatureList             - list of Z Signature
            + ActionSignatureList        - list of Circus ActionSignature
            + NameSetSignatureList       - list of Circus NameSetSignature
            + ChannnelSetSignatureList   - list of Circus ChannelSetSignature
            + CommunicationSignatureList - list of Circus CommunicationSignature
          
          Methods available:  
            a) List[SignatureList]         getSignatureList()           = method by GnAST
            b) ZSignatureList              getMainSignatures()          = getSignatureList().get(MAIN_SIGNATURES_INDEX);
               1) Signature                   getFormalParamOrIndexes()     = getMainSignatures().get(FORMAL_PARAMS_INDEX);              
               2) Signature                   getUsedChannels()             = getMainSignatures().get(USED_CHANNELS_INDEX);
               3) Signature                   getStateSignature()           = getMainSignatures().get(STATE_SIGNATURE_INDEX);
            c) ZSignatureList              getLocalZSignatures()        = getSignatureList().get(ZLOCAL_SIGNATURES_INDEX);
            d) ActionSignatureList         getActionSignatures()        = getSignatureList().get(ACTION_SIGNATURES_INDEX);          
            e) CommunicationSignatureList  getUsedCommunications()      = getSignatureList().get(COMM_SIGNATURES_INDEX);            
            f) NameSetSignatureList        getUsedNameSets()            = getSignatureList().get(NAMESET_SIGNATURES_INDEX);
            g) ChannelSetSignatureList     getUsedChannelSets()         = getSignatureList().get(CHANNEL_SIGNATURES_INDEX);
            h) ProcessSignatureList        getProcessSignatures()       = getSignatureList().get(PROCESS_SIGNATURES_INDEX);
            i) boolean                     isBasicProcess()             = getProcessSignatures().isEmpty();            
            
          Types not provided by GnAST :
            NameSetSignatureList      : Map[ZName, List[NameSet]]
            ChannelSetSignatureList   : Map[ZName, List[ChannelSet]]
            CommunicationSignatureList: Map[ZName, List[Communication]]            
          
          Meaning: GLOBAL_INVAIRNAT: all methods return a non-null value
          
            a) access method by GnAST - automatically
            
            b) access method by GnAST - manually via vm
               1) formal parameters or indexes, depending on getUsage()
               2) used channels and their declared types, which could be generic
               3) state signature as declared by \circstate\ expressions
                  (i.e., it does not include local variables added to the state)
                  
                  INVARIANT: isBasicProcess() || getStateSignature().isEmpty()
                  (i.e., only basic process can have state signatures, which can be empty)
                  
            c) list of Z signatures for Z paragraphs, commands, and TransformerPara declared within a basic process
               (i.e., VarDeclCommand will add variables to the process state scope, but not to
                      the process state signature)
            
               INVARIANT: isBasicProcess() || getLocalZSignatures().isEmpty()
               (i.e., only basic process can have local paragraphs, which can be empty)
               
            d) list of Circus ActionSignature for actions declared within a basic process               
            
               INVARIANT: IF isBasicProcess() THEN 
                              !getActionSignatures().isEmpty() 
                          ELSE
                              getActionSignatures().isEmpty()  
               (i.e., only basic process can have actions, which cannot be empty because 
                      they have at least the main action)
            
            e) list of used communications by each action (Map[ZName, List[Communication]])
               (i.e., the communications in each pair are annotated as a power type of CommunicationType.
                      CommunicationType contains the instantiated channel type as well as the type of
                      each field, which may be different from the channel type; 
                      e.g., suppose that "[X, Y] c \in X \cross Y" and "c.0.1" is used, 
                            the communication type is: CommType[c:\arithmos \cross \arithmos; i: \nat; j: \nat])
                      
               INVARIANT: isBasicProcess() || getUsedNameSets().isEmpty()
               (i.e., only basic process can have name sets, which can be empty)             
                      
            f) list of used name sets by each action (Map[ZName, List[NameSet]])
               (i.e., the name sets in each pair are annotated as a power type of NameSetType)
                      
               INVARIANT: isBasicProcess() || getUsedNameSets().isEmpty()
               (i.e., only basic process can have name sets, which can be empty)
               
             g) list of used channel sets by each action (Map[ZName, List[ChannelSet]])
                (i.e., the channel sets in each pair are annotated as a power type of ChannelSetType)
                      
               NOTE: parallel processes can have channel sets, which are mapped to the process name
               
             h) list of process signatures related to this process
                (i.e., a compound processes, ultimatelly formed by basic processes)
                
             i) auxiliary method to add invariants (as assertions) to other methods
               
          NOTE: Tools that semantically represent all processes as basic process can
                use the information on getProcessSignatures() to collect all basic 
                process information and build a merged signature according to the 
                Circus refinement calculus.
             
          Indexes:
            MAIN_SIGNATURES_INDEX   = 0;
                  FORMAL_PARAMS_INDEX   = 0;
                  USED_CHANNELS_INDEX   = 1;                  
                  STATE_SIGNATURE_INDEX = 2;
            ZLOCAL_SIGNATURES_INDEX = 1;
            ACTION_SIGNATURES_INDEX = 2;  
            COMM_SIGNATURES_INDEX   = 3;
            PROCESS_SIGNATURES_INDEX= 4;
            NAMESET_SIGNATURES_INDEX= 5;
            CHANNEL_SIGNATURES_INDEX= 6;
          
          PS: We leave getSignatureList() unbounded to allow further extension with new lists if needed,
              where minOccurs MUST be at least CHANNEL_SIGNATURES_INDEX=+1 (6)
          
          Process channel sets only - 
          
          INVARIANT: !isBasicProcess() || getProcessChannelSets().isEmpty()
          (i.e., only parallel processes, which are not basic processes, can have them)
          
          Because BasicProcessSignature uses yet another SignatureList, 
          we need  more than one SignatureList, so we have a list of signature lists!
          So, we add through GnAST the following convenience methods:       
          
          <ul>
            <li>
              <ul>
                <li></li>                              
              </ul>
            </li>            
          </ul>
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Additional process-level signatures in Circus -->
  
  <xs:element name="ActionSignature" type="CIRCUS:ActionSignature"
              substitutionGroup="CIRCUS:CircusSignature">
    <xs:annotation>
      <xs:documentation>
        <p>
          An action signature consists of the action name, formal parameters, 
          the channels used, the communications, channel sets and name sets used.
        </p>
        <p>
          <ul>
            <li>Signature getFormalParams() = getSignatureList().get(0)</li>            
            <li>Signature getLocalVars()    = getSignatureList().get(1)</li>
            <li>Signature getUsedChannels() = getSignatureList().get(2)</li>
          </ul>          
          One can also access the communication list containing all the 
          communications involved in this action. That is, all the 
          channel uses with resolved generic types and communication pattern.
          Note the communication pattern collective type may differ (and may be
          non-unifiable) from the channel declared type (e.g., c: X x Y x Z, c?x?w).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
    
  <!-- Lists used by Circus elements -->
  
  <xs:element name="ActionList" type="CIRCUS:ActionList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract Action list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CircusActionList" type="CIRCUS:CircusActionList"
              substitutionGroup="CIRCUS:ActionList">
    <xs:annotation>
      <xs:documentation>
        A list with (concrete) Circus actions. An alternative implementation
        would be a list with action jokers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
   <xs:element name="NameSetList" type="CIRCUS:NameSetList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract name set list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CircusNameSetList" type="CIRCUS:CircusNameSetList"
              substitutionGroup="CIRCUS:NameSetList">
    <xs:annotation>
      <xs:documentation>
        A list with (concrete) Circus name sets An alternative implementation
        would be a list with name set jokers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
   <xs:element name="ChannelSetList" type="CIRCUS:ChannelSetList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract name set list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CircusChannelSetList" type="CIRCUS:CircusChannelSetList"
              substitutionGroup="CIRCUS:ChannelSetList">
    <xs:annotation>
      <xs:documentation>
        A list with (concrete) Circus name sets An alternative implementation
        would be a list with name set jokers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CommunicationList" type="CIRCUS:CommunicationList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract communication list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CircusCommunicationList" type="CIRCUS:CircusCommunicationList"
              substitutionGroup="CIRCUS:CommunicationList">
    <xs:annotation>
      <xs:documentation>
        A list with (concrete) Circus communications. An alternative implementation
        would be a list with communication jokers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="FieldList" type="CIRCUS:FieldList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract communication fields list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CircusFieldList" type="CIRCUS:CircusFieldList"
              substitutionGroup="CIRCUS:FieldList">
    <xs:annotation>
      <xs:documentation>
        A communication fields list. An alternative implementation would be a
        list with communication field jokers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="SignatureList" type="CIRCUS:SignatureList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract signature list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ZSignatureList" type="CIRCUS:ZSignatureList"
              substitutionGroup="CIRCUS:SignatureList">
    <xs:annotation>
      <xs:documentation>
        An signature list with Z signatures.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ActionSignatureList" type="CIRCUS:ActionSignatureList" 
              substitutionGroup="CIRCUS:SignatureList">
    <xs:annotation>
      <xs:documentation>
        An signature list with action signatures.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessSignatureList" type="CIRCUS:ProcessSignatureList" 
              substitutionGroup="CIRCUS:SignatureList">
    <xs:annotation>
      <xs:documentation>
        An signature list with process signatures.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
    
  <!-- Term Annotations defined by Circus -->
  
  <xs:element name="CircusAnn" type="CIRCUS:CircusAnn" abstract="true" substitutionGroup="Z:Ann">
    <xs:annotation>
      <xs:documentation>
        Abstract annotation type for all term annotations used within Circus.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CircusStateAnn" type="CIRCUS:CircusAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
      <xs:documentation>
        Defines if a given paragraph is the process state. 
        The parser must enforce such a paragraph is a schema.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="OnTheFlyDefAnn" type="CIRCUS:CircusAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
      <xs:documentation>
        Defines an on-the-fly definition annotation used for both Process and Action terms.            
        It must be included into <code>ParamAction</code> and <code>ParamProcess</code> by 
        the parser whenever an on-the-fly definition occurs. It is also used for on-the-fly
        schema definitions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="OutputFieldAnn" type="CIRCUS:CircusAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
      <xs:documentation>
        Marks a dot field as an output field. That is, c!x instead of c.x
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ImplicitChannelAnn" type="CIRCUS:CircusAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
      <xs:documentation>
        Annotation used for implicitly declared channnels via indexed processes.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProofObligationAnn" type="CIRCUS:ProofObligationAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
      <xs:documentation>
        Annotation used for attaching proof obligations to terms. For instance, the typechecker
        adds a proof obligation annotation to expressions in iterated declarations to make sure
        they are not infinite.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ActionSignatureAnn" type="CIRCUS:ActionSignatureAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
      <xs:documentation>
        An action signature wrapped within an annotation, where generic type are resolved.
        This is just like SignatureAnn.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessSignatureAnn" type="CIRCUS:ProcessSignatureAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
      <xs:documentation>
        A process signature wrapped within an annotation, where generic type are resolved.
        This is just like SignatureAnn.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="StateUpdate" type="CIRCUS:StateUpdate" substitutionGroup="Z:QntPred">
    <xs:annotation>
      <xs:documentation>
        <p>
          Process state update is a list of assignment pairs representing
          how state updates took place sequentially. For complex compositional 
          operators, such as external choice and parallel composition, there are
          semantic functions that define how the state merge occurs, which
          is much like what happens in the UTP.
        </p>
        <p>
          These classes shall never be instantiated by the user manually.
          They are produced by Circus tools as they go along performing the
          varied state update forms the language allows.
        </p>
        <p>
          It is a Z quantified predicate extended to contain a list of
          assignment pairs. Essentially, a tool, say a typechecker, collects 
          the assignment pairs representing a particular branch of the AST.
          This can be built backwards as it traverses the AST during typechecking.
          After that, another tool, say an animator or model checker, can 
          apply necessary transformations needed to the assignment
          pairs list so that the merge of information reflect the denotational
          semantics of a particular construct. The resulting predicate representing
          the whole state update is then feed into the actual structure of a QntPred,
          where the SchText is the state components (and invariant), and the predicate
          is the calculated state merge. (!) 
        </p>
        <p>
          It is part of a ProcessSignature. It is also be part of a StateUpdateAnn.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="StateUpdateAnn" type="CIRCUS:StateUpdateAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
      <xs:documentation>
        <p>Annotation for StateUpdate instances outside ProcessSignature 
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- ***************************************************************** -->
  <!-- Definitions of complexTypes in the order of usage by the elements -->
  <!-- ***************************************************************** -->

  <!-- Outermost Paragraph Types -->
  <xs:complexType name="ChannelPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>          
          <!--<xs:element ref="CIRCUS:ChannelDecl" minOccurs="0" maxOccurs="unbounded"/>-->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ChannelDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <!-- Because the new JAXB feature for XML read/writing does not allow
               multiple ref elements with the same type, we are forced to use lists.
               Nevertheless, we add via GnAST the necessary convenience methods. 
               
               All productions affected and modified were: 
               
               ChannelDecl, Process2, BasicProcess, AlphabetisedParallelProcess,
               Action2, ParAction, AlphabetisedParallelAction, SpecStmtCommand,
               ActionTransformerPred, ProcessTransformerPred, and ActionSignature.
               
               All new productions must bare this in mind from now on (revision 5826). 
               Convenience setXXX methods follow the same implementation as Z:Expr2.
            -->
           
          <!-- This returns a list of NameList containing exactly two elements.
               The first is the non-null (possibly emptty) generic formals, 
               whereas the second is the list of channel names for the "channel" 
               keyword, or non-null empty list for the "channelFrom" keyword. -->                    
          <xs:element ref="Z:NameList" minOccurs="2" maxOccurs="2"/>
          
          <!-- Channel type for typed channels, null for synchronisation channels, or RefExpr for ChannelFrom -->
          <xs:element ref="Z:Expr" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>           
  
  <xs:complexType name="ChannelSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:NameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Name"/>            
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ProcessPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <!-- Although the syntax is \circprocess [X, Y] N \defs ...,
               I couldn't figure out how to put the generics before the
               name without causing an ambiguity complaint by the XML
               validator :( -->
          <xs:element ref="Z:Name"/>            
          <xs:element ref="Z:NameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusProcess"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusConjPara">
    <xs:complexContent>
      <xs:extension base="Z:Para"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="TransformerPara">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusConjPara">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="CIRCUS:TransformerPred"/>                      
        </xs:sequence>                  
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <!-- Channel Set Expression complexTypes -->
  <xs:complexType name="ChannelSet">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="CircusChannelSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  
  <xs:complexType name="BasicChannelSetExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>        
          <xs:element ref="CIRCUS:CommunicationList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <!-- Process Definition complexType -->
  <xs:complexType name="CircusProcess">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="Process1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusProcess"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>                 
          <!-- 
          In Circus, the only possibility is QualifiedDecl and the parser must rule others out.
          ConstDecl and InclDecl are to be avoided, as parameters in CSP do not come from schemas.
          -->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessD"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIte"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Process2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>
          <!-- Because the new JAXB feature for XML read/writing does not allow
               multiple ref elements with the same type, we are forced to use lists.
               Nevertheless, we add via GnAST the necessary convenience methods.
               getCircusProcess().get(0) = getLeftProc
               getCircusProcess().get(1) = getRightProc          
               
              <xs:element ref="CIRCUS:CircusProcess">
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="LeftProc"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element>
              <xs:element ref="CIRCUS:CircusProcess">
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="RightProc"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element>            
          -->      
          <xs:element ref="CIRCUS:CircusProcess" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>     
  
  <!-- Bssic Process -->
  <xs:complexType name="BasicProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <!--
          REFACTORING: Collapsed all BasicProcess elements into a single ParaList
                       in order to properly implement new JAXB features. See 
                       details below.
          -->
          
          <!--
          This will create a get/setParaList method accessing all paragraphs.
          We will also add the following convenience methods:
          
          Para getStatePara() 
          -> returns the paragraph within ParaList with a CircusStateAnn 
             annotation or throw a UnsupportedASTException otherwise. 
             That is because, by default, the  parser always create a state.
                            
             The parser allows schema boxes, horizontal schemas, and schema actions.
             That rules out generic schemas (or generic abbreviations), as the 
             geneirc types on schemas must come from the process generic formals.
                            
              Also, we allow implicit circus state to be declared on the fly,
              where the default name is "$$defaultSt". That is, we allow
              Expr production after \circstate\ as well. For example,
              "\circstate\ S \land T", we translate the on-the-fly description 
              to the following convention: "\circstate\ $$defaultState == S \land T".

              In the case of a BasicProcess without state, the parser MUST  
              include an empty schema for it as if it had been declared as 
              "\circstate $$defaultSt == [~ | true ~]". 
              
          CircusAction getMainAction()
          -> The main action is the action within the ActionPara inside
             OnTheFlyPara. It is annotated with an OnTheFlyDefAnn.          
          
          ZParaList getLocalPara()
          -> Contains both Z and Circus paragraphs. 
             It does not contain any OnTheFlyPara.             
             It may contain the state para, if it was declared 
             using a ConstDecl (i.e. \circstate\ S == expr).
          
          ZParaList getOnTheFlyPara(),
          -> Contains implicitly declared ActionPara. 
             This includes the main action, which is always implicitly declared.
             Elements are annotated with an OnTheFlyDefAnn to be used by
             the typechecker. If it is a state, a CircusStateAnn is also
             included, which can only happens in the case where an expression
             is used (i.e. \circstate S; \circstate (S \land T); etc). 
             
             ActionPara are named as $$implicitActN, whereas 
             the state is named "$$defaultSt" and the main 
             action "$$mainAction".
             
          INVARIANTS: 
          
          1) Main action is never null and always within on-the-fly paragraphs            
          
          * Logic: 
          mainAct \in ohTheFlyPara
          
          * Java:
          assert getZOhTheFlyPara().contains(createActionPara("$$mainAction", getMainAction());
          
          2) State para is never null and always within either local or on-the-fly
            paragraphs, where the default state is just "$$defaultSt -> [|true]".
          
          * Logic:
          CircStateAnn \in state.getAnns()          
          OnTheFlyDefAnn \in state.getAnns()    \implies state \in ohTheFlyPara
          OnTheFlyDefAnn \notin state.getAnns() \implies state \in localPara
          
          * Java:
          assert ....
          
          3) Size is always at least two (i.e. state + main action) 
             TODO: Think about perhaps not in case of joker(?)
          
          4) Local and on-the-fly para form a partition of ParaList            
          
          PS: Add those and other Circus.xsd invariants as unit tests for the parser.
          -->
          <xs:element ref="Z:ParaList"/>            
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Process Definition :: Calls --> 
  
  <xs:complexType name="CallProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <!-- CallExpr because it can contain generic actuals -->
          <xs:element ref="Z:RefExpr">                    
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="CallExpr"
                               generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="Z:ExprList">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Actuals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>       
        </xs:sequence>
        <xs:attribute name="Usage" type="CIRCUS:CallUsage" use="optional" default="Parameterised"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:simpleType name="CallUsage">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Parameterised"/>
      <xs:enumeration value="Indexed"/>
      <!-- 
      <xs:enumeration value="Normal"/>      
      <xs:enumeration value="Gen"/>
      <xs:enumeration value="GenParam"/>
      <xs:enumeration value="GenIndex"/>
      -->
    </xs:restriction>
  </xs:simpleType> 
  
  
  <!-- Process Definition :: Unary -->
  <xs:complexType name="HideProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RenameProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>                            
          <xs:element ref="CIRCUS:AssignmentPairs">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="AssignmentPairs">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <!-- <xs:element ref="Z:Name" minOccurs="1" maxOccurs="unbounded"> -->
          <xs:element ref="Z:NameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LHS"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>      
          <!-- <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"> -->
          <xs:element ref="Z:ExprList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RHS"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  
  
  <!-- Process Definition :: Binary -->
  
  <xs:complexType name="ParProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process2"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="AlphabetisedParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcess">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAlpha"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAlpha"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          -->
          <xs:element ref="CIRCUS:ChannelSet" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 
  
  <!-- Process Definition :: Expressions -->  
  
  <!--
  <xs:complexType name="ProcessE">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>          
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  <xs:complexType name="ActualParamProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessE">
        <xs:sequence>
          <xs:element ref="CIRCUS:ParamProcessDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="InstantiationProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessE">
        <xs:sequence>
          <xs:element ref="CIRCUS:IndexedProcessDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  -->
  
  <!-- Process Definition :: Unary :: Declaration :: Iterated -->
  <xs:complexType name="ParProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIte"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcessIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Process Definition :: Unary :: Declaration :: Iterated :: Indexed -->
  <xs:complexType name="ParProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIdx"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcessIdx">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Process Paragraphs complexTypes -->
  <xs:complexType name="NameSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ActionPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Name Set Expression complexTypes -->
  <xs:complexType name="NameSet">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="CircusNameSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <!-- Action complexType -->    
  <xs:complexType name="CircusAction">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action2">    
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <!-- Because the new JAXB feature for XML read/writing does not allow
           multiple ref elements with the same type, we are forced to use lists.
           Nevertheless, we add via GnAST the necessary convenience methods.
           getCircusProcess().get(0) = getLeftProc
           getCircusProcess().get(1) = getRightProc                

           <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          --> 
          <xs:element ref="CIRCUS:CircusAction" minOccurs="2" maxOccurs="2"/>    
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>                  
          <!-- 
          In Circus, the only possibility is QualifiedDecl and the parser must rule others out.
          ConstDecl and InclDecl are to be avoided, as parameters in CSP do not come from schemas.
          -->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionD"/>
    </xs:complexContent>
  </xs:complexType> 
  
  <xs:complexType name="CircusCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="SchExprAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <!-- 
          Z:Expr instead of Z:SchExpr or SchText because we want a schema action to be an expression. 
          That means, we can have a schema definition as well as an expression using schemas (as in 
          Spivey's SchExpr tree - that is not in the Z-Standard. From the CZT, these are reflected as 
          Z:SchExpr, Z:SchExpr2, and Z:HideExpr.
          -->          
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CallAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="Z:Name"/>          
          <xs:element ref="Z:ExprList"/>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  
  <!-- CSP Action complexType -->
  <xs:complexType name="BasicAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction"/>
    </xs:complexContent>
  </xs:complexType>
  
  <!--
  <xs:complexType name="ActualParamAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ParamActionDesc"/>          
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  -->

  <!-- CSP Action complexType :: Unary -->
  <xs:complexType name="MuAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GuardedAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HideAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PrefixingAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:Communication">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SubstitutionAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>                   
          <!-- Accommodate Z.xsd changes:
          <xs:element name="OldNames" type="Z:Name" minOccurs="1" maxOccurs="unbounded"/>
          <xs:element name="NewNames" type="Z:Name" minOccurs="1" maxOccurs="unbounded"/>
          -->
          <xs:element ref="Z:RenameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Action complexType :: Unary :: Declaration :: Iterated -->
  <xs:complexType name="ParActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParActionIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Action complexType :: Binary -->
  <xs:complexType name="ParAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action2">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftNameSet"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightNameSet"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          -->
          <xs:element ref="CIRCUS:NameSet" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AlphabetisedParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAlpha"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAlpha"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>            
          </xs:element>
          -->
          <xs:element ref="CIRCUS:ChannelSet" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Lists used by Circus terms --> 
  
  <xs:complexType name="ActionList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusActionList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionList">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusAction" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="NameSetList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusNameSetList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSetList">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ChannelSetList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusChannelSetList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSetList">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="CommunicationList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusCommunicationList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CommunicationList">
        <xs:sequence>
          <xs:element ref="CIRCUS:Communication" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="FieldList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusFieldList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:FieldList">
        <xs:sequence>
          <xs:element ref="CIRCUS:Field" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="SignatureList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ZSignatureList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:SignatureList">
        <xs:sequence>
          <xs:element ref="Z:Signature" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ProcessSignatureList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:SignatureList">
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessSignature" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ActionSignatureList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:SignatureList">
        <xs:sequence>
          <xs:element ref="CIRCUS:ActionSignature" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   
  
  <xs:complexType name="StateUpdate">
    <xs:complexContent>
      <xs:extension base="Z:QntPred">
        <xs:sequence>
          <!-- 
            TODO: DESIGN: is this really here? CHECK: come back when doing compiler.
          
            At least you must have the types correct, even if absolutely nondeterministically
            e.g., St == [ x: \nat ].... Op == [ \Delta St | P ] 
                  StateUpdate=(\forall \Delta St; St_0 @ P[x_0/x']) \circspot x := x_0
            
            That is, we have for all state variables, constants updated according to the 
            state update operation. In this way, all state updates can be normalised to
            assignment of logical constants - see Op. Sem. paper
            
            As we must have at least one assignment pair for the state invariant, 
            minOccurs is set to 1.
            -->
          <xs:element ref="CIRCUS:AssignmentPairs" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Communication complexType -->
  <xs:complexType name="Communication">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <!-- RefExpr because it can contain generic actuals -->
          <xs:element ref="Z:RefExpr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ChannelExpr"
                               generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:FieldList"/>
        </xs:sequence>
        <xs:attribute name="CommUsage" type="CIRCUS:CommUsage" use="optional" default="Normal"/>
        <xs:attribute name="CommPattern" type="CIRCUS:CommPattern" use="optional" default="Synch"/>
        <xs:attribute name="MultiSych" type="xs:nonNegativeInteger" use="optional" default="0"/>
        <xs:attribute name="Indexed" type="xs:boolean" use="optional" default="false"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <!-- 
    Invariant: 
      Synch = getFields().isEmpty() 
      Input = !getFields().isEmpty() && forall getField().get(i) instanceof InputField            
      Output= !getFields().isEmpty() && forall getField().get(i) instanceof DotField
      Mixed = !getFields().isEmpty() && there are more than one class: InputField, DotField).
      ChannelSet = getFields().isEmpty && the communication belongs to a BasicChannelSetExpr communication list
  -->
  <xs:simpleType name="CommPattern">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Synch"/>
      <xs:enumeration value="Input"/>
      <xs:enumeration value="Output"/>
      <xs:enumeration value="Mixed"/>
      <xs:enumeration value="ChannelSet"/>      
    </xs:restriction>
  </xs:simpleType>  
  
  <!-- 
  We may have either normal, or generic. As generic channels can 
  be either implicit or explicit. An extra method is added via
  GnAST for this. For the XML, the way to distinguish it is to 
  check whether the RefExpr name contains expressions or not.
  
  Implicit generic means channels declared with generic formals
  but used without instantiating then.
  -->
  <xs:simpleType name="CommUsage">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Normal"/>
      <xs:enumeration value="Generic"/>
    </xs:restriction>
  </xs:simpleType>  
  
  <!-- CSP Communication parameters complexType -->
  
  <xs:complexType name="Field">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="InputField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element ref="Z:Name">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="VariableName"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Restriction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="DotField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Parameterised Commands complextype -->  
  <xs:complexType name="QualifiedDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <!-- Parser must inforce that minOccurs="1"! -->
          <xs:element ref="Z:NameList"/>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
        <xs:attribute name="ParamQualifier" type="CIRCUS:ParamQualifier" use="optional" default="Value"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="ParamQualifier">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Value"/>
      <xs:enumeration value="Result"/>
      <xs:enumeration value="ValueResult"/>
    </xs:restriction>
  </xs:simpleType>  
  
  <!-- Circus Commands complextype -->
  <xs:complexType name="SpecStmtCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>          
          <xs:element ref="Z:NameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Frame"
                               generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="Z:Pred" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AssignmentCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>                  
          <xs:element ref="CIRCUS:AssignmentPairs">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CircusGuardedCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:GuardedAction" minOccurs="1" maxOccurs="unbounded"/>
          -->
          <xs:element ref="CIRCUS:ActionList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VarDeclCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>                    
          <!-- 
          In Circus, the possibilites are VarDecl and InclDecl only and the parser must rule out ConstDecl.
          Implementations should consider at least VarDecl, and InclDecl could be avoid for simplicity.
          -->
          <xs:element ref="Z:DeclList"/>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Circus predicates -->
  
  <xs:complexType name="TransformerPred">
    <xs:complexContent>
      <xs:extension base="Z:Pred">
        <xs:sequence>
          <!-- Quantified alphabets -->
          <xs:element ref="Z:SchText"/>          
        </xs:sequence>
        <xs:attribute name="Transformation" type="CIRCUS:Transformation" use="optional" default="Refinement"/>        
        <xs:attribute name="Model" type="CIRCUS:Model" use="optional" default="FlDv"/>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:simpleType name="Transformation">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Refinement"/>
      <xs:enumeration value="Equivalence"/>
      <xs:enumeration value="Simulation"/>
    </xs:restriction>
  </xs:simpleType>
  
  <xs:simpleType name="Model">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Tr"/>
      <xs:enumeration value="SFl"/>
      <xs:enumeration value="FlDv"/>
    </xs:restriction>
  </xs:simpleType>  
  
  <xs:complexType name="ActionTransformerPred">
    <xs:complexContent>
      <xs:extension base="CIRCUS:TransformerPred">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Spec"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Impl"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          -->
          <xs:element ref="CIRCUS:CircusAction" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ProcessTransformerPred">
    <xs:complexContent>
      <xs:extension base="CIRCUS:TransformerPred">
        <xs:sequence>                   
          <xs:element ref="CIRCUS:CircusProcess" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Additional Circus actions for Local Environments of the operational semantics -->
  <xs:complexType name="LetAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="LetMuAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:LetAction">
        <xs:sequence>
          <!-- List of ActionPara to handle mutual recursion -->
          <xs:element ref="Z:ParaList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="LetVarAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:LetAction">
        <xs:sequence>                                       
          <xs:element ref="Z:DeclList"/>
          <!-- Invariant: getDeclarations().size()==getValues.size() -->          
          <xs:element ref="Z:ExprList"/>            
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="SigmaExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:RefExpr">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Channel"
                               generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="Z:Expr">            
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Value"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Circus Types and Signatures -->  
  
  <xs:complexType name="CircusType">
    <xs:complexContent>
      <xs:extension base="Z:Type2"/>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="CircusSigType">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusType">
        <xs:sequence>           
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <!-- The first name type pair is the channel set/name set name and type, 
       whereas the remainder name type pairs represent the 
       communication pattern. So c?x?y   c: N1 x N2 x N3               

       getSignature().getNameTypePair().get(0) = NameTypePair(ZName("c"), ProdType(List<N1, N2, N3>))
          getChannelName() = getSignature().getNameTypePair().get(0).getName()
          getChannelType() = getSignature().getNameTypePair().get(0).getType()

       getSignature().getNameTypePair().sublist(1, getSignature().getNameTypePair().size()) = 
          List<NameTypePair(ZName("x"), Type2("N1")), NameTypePair(ZName("y"), ProdType(List<N2, N3>))>

          getCommunicationPattern = getSignature().getNameTypePair().sublist(1, getSignature().getNameTypePair().size())               
   -->
  <!--
  <xs:complexType name="ChannelSetType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>          
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="NameSetType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>          
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  <xs:complexType name="CommunicationType">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusType">
        <xs:sequence>
           The first name type pair is the channel name and type, 
               whereas the remainder name type pairs represent the 
               communication pattern. So c?x?y   c: N1 x N2 x N3               
               
               getSignature().getNameTypePair().get(0) = NameTypePair(ZName("c"), ProdType(List<N1, N2, N3>))
                  getChannelName() = getSignature().getNameTypePair().get(0).getName()
                  getChannelType() = getSignature().getNameTypePair().get(0).getType()
                  
               getSignature().getNameTypePair().sublist(1, getSignature().getNameTypePair().size()) = 
                  List<NameTypePair(ZName("x"), Type2("N1")), NameTypePair(ZName("y"), ProdType(List<N2, N3>))>
                  
                  getCommunicationPattern = getSignature().getNameTypePair().sublist(1, getSignature().getNameTypePair().size())               
           
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  -->
  
  <xs:complexType name="ChannelType">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusType">
        <xs:sequence>
          <xs:element ref="Z:Type2">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Type"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ProcessType">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusType">
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessSignature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ActionType">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusType">
        <xs:sequence>
          <xs:element ref="CIRCUS:ActionSignature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  
  <xs:complexType name="CircusSignature">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <!-- maybe this is useless here: ActionSignature within actions do not have names? But they do within ActionPara -->
          <xs:element ref="Z:Name"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ProcessSignature">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusSignature">
        <xs:sequence>               
          <!--
          List<NameList> getNameList(), where NameList can be:
            + ZNameList     - list of concrete Z names
            + JokerNameList - list of joker names
            
          Methods available:
            a) List<NameList> getNameList()             = method by GnAST
            b) ZNameList      getGenFormals()           = ZUtils.assertZNameList(getNameList().get(GENFORMALS_INDEX));            
            c) ZNameList      getTransformerParaName()  = ZUtils.assertZNameList(getNameList().get(TRANSFORMER_INDEX));            
          
          Indexes:
            GENFORMALS_INDEX  = 0;
            TRANSFORMER_INDEX = 1;
            
          PS: We leave getNameList() unbounded to allow further extension with new lists if needed,
              where minOccurs MUST be at least TRANSFORMER_INDEX+1 (2)
          
          <xs:element ref="Z:NameList" minOccurs="2" maxOccurs="2"/>
          
          DESIGN: as TransformerPara has a special GIVEN type (like Synchronisation does)
                  it will be part of the getLocalZSignatures() - see below.
          -->          
          <xs:element ref="Z:ZNameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"
                               generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          
          <!--     
          List<SignatureList> getSignatureList(), where SignatureList can be:
            + ZSignatureList             - list of Z Signature
            + ActionSignatureList        - list of Circus ActionSignature
            + NameSetSignatureList       - list of Circus NameSetSignature
            + ChannnelSetSignatureList   - list of Circus ChannelSetSignature
            + CommunicationSignatureList - list of Circus CommunicationSignature
          
          Methods available:  
            a) List<SignatureList>         getSignatureList()           = method by GnAST
            b) ZSignatureList              getMainSignatures()          = getSignatureList().get(MAIN_SIGNATURES_INDEX);
               1) Signature                   getFormalParamOrIndexes()     = getMainSignatures().get(FORMAL_PARAMS_INDEX);              
               2) Signature                   getUsedChannels()             = getMainSignatures().get(USED_CHANNELS_INDEX);
               3) Signature                   getStateSignature()           = getMainSignatures().get(STATE_SIGNATURE_INDEX);
            c) ZSignatureList              getLocalZSignatures()        = getSignatureList().get(ZLOCAL_SIGNATURES_INDEX);
            d) ActionSignatureList         getActionSignatures()        = getSignatureList().get(ACTION_SIGNATURES_INDEX);          
            e) CommunicationSignatureList  getUsedCommunications()      = getSignatureList().get(COMM_SIGNATURES_INDEX);            
            f) NameSetSignatureList        getUsedNameSets()            = getSignatureList().get(NAMESET_SIGNATURES_INDEX);
            g) ChannelSetSignatureList     getUsedChannelSets()         = getSignatureList().get(CHANNEL_SIGNATURES_INDEX);
            h) ProcessSignatureList        getProcessSignatures()       = getSignatureList().get(PROCESS_SIGNATURES_INDEX);
            i) boolean                     isBasicProcess()             = getProcessSignatures().isEmpty();            
            
          Types not provided by GnAST :
            NameSetSignatureList      : Map[ZName, List[NameSet]]
            ChannelSetSignatureList   : Map[ZName, List[ChannelSet]]
            CommunicationSignatureList: Map[ZName, List[Communication]]            
          
          Meaning: GLOBAL_INVAIRNAT: all methods return a non-null value
          
            a) access method by GnAST - automatically
            
            b) access method by GnAST - manually via vm
               1) formal parameters or indexes, depending on getUsage()
               2) used channels and their declared types, which could be generic
               3) state signature as declared by \circstate\ expressions
                  (i.e., it does not include local variables added to the state)
                  
                  INVARIANT: isBasicProcess() || getStateSignature().isEmpty()
                  (i.e., only basic process can have state signatures, which can be empty)
                  
            c) list of Z signatures for Z paragraphs, commands, and TransformerPara declared within a basic process
               (i.e., VarDeclCommand will add variables to the process state scope, but not to
                      the process state signature)
            
               INVARIANT: isBasicProcess() || getLocalZSignatures().isEmpty()
               (i.e., only basic process can have local paragraphs, which can be empty)
               
            d) list of Circus ActionSignature for actions declared within a basic process               
            
               INVARIANT: IF isBasicProcess() THEN 
                              !getActionSignatures().isEmpty() 
                          ELSE
                              getActionSignatures().isEmpty()  
               (i.e., only basic process can have actions, which cannot be empty because 
                      they have at least the main action)
            
            e) list of used communications by each action (Map[ZName, List[Communication]])
               (i.e., the communications in each pair are annotated as a power type of CommunicationType.
                      CommunicationType contains the instantiated channel type as well as the type of
                      each field, which may be different from the channel type; 
                      e.g., suppose that "[X, Y] c \in X \cross Y" and "c.0.1" is used, 
                            the communication type is: CommType[c:\arithmos \cross \arithmos; i: \nat; j: \nat])
                      
               INVARIANT: isBasicProcess() || getUsedNameSets().isEmpty()
               (i.e., only basic process can have name sets, which can be empty)             
                      
            f) list of used name sets by each action (Map[ZName, List[NameSet]])
               (i.e., the name sets in each pair are annotated as a power type of NameSetType)
                      
               INVARIANT: isBasicProcess() || getUsedNameSets().isEmpty()
               (i.e., only basic process can have name sets, which can be empty)
               
             g) list of used channel sets by each action (Map[ZName, List[ChannelSet]])
                (i.e., the channel sets in each pair are annotated as a power type of ChannelSetType)
                      
               NOTE: parallel processes can have channel sets, which are mapped to the process name
               
             h) list of process signatures related to this process
                (i.e., a compound processes, ultimatelly formed by basic processes)
                
             i) auxiliary method to add invariants (as assertions) to other methods
               
          NOTE: Tools that semantically represent all processes as basic process can
                use the information on getProcessSignatures() to collect all basic 
                process information and build a merged signature according to the 
                Circus refinement calculus.
             
          Indexes:
            MAIN_SIGNATURES_INDEX   = 0;
                  FORMAL_PARAMS_INDEX   = 0;
                  USED_CHANNELS_INDEX   = 1;                  
                  STATE_SIGNATURE_INDEX = 2;
            ZLOCAL_SIGNATURES_INDEX = 1;
            ACTION_SIGNATURES_INDEX = 2;  
            COMM_SIGNATURES_INDEX   = 3;
            PROCESS_SIGNATURES_INDEX= 4;
            NAMESET_SIGNATURES_INDEX= 5;
            CHANNEL_SIGNATURES_INDEX= 6;
          
          PS: We leave getSignatureList() unbounded to allow further extension with new lists if needed,
              where minOccurs MUST be at least CHANNEL_SIGNATURES_INDEX=+1 (6)
          -->
          <xs:element ref="CIRCUS:SignatureList" minOccurs="2" maxOccurs="unbounded"/>
          <!-- 
          Process channel sets only - 
          
          INVARIANT: !isBasicProcess() || getProcessChannelSets().isEmpty()
          (i.e., only parallel processes, which are not basic processes, can have them)
          -->
          <xs:element ref="CIRCUS:ChannelSetList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ProcessChannelSets"
                               generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <!--
          The state update is a quantified predicate containing
          -->
          <xs:element ref="CIRCUS:StateUpdate">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
  <!-- A process might have neither formal parameters nor indexes, hence minOccurs="0" for Signature below. 
        Or it might have either of them (i.e. formal parameters or indexes) but never both. -->
        <xs:attribute name="Usage" type="CIRCUS:CallUsage" use="optional" default="Parameterised"/>        
      </xs:extension>            
    </xs:complexContent>
  </xs:complexType>   
  
  <xs:complexType name="ActionSignature">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusSignature">
        <xs:sequence>
          <!-- 
          List[Signature] getSignatureList()
          Signature getFormalParams() = getSignatureList().get(FORMAL_PARAMS_INDEX)
          Signature getLocalVars()    = getSignatureList().get(LOCAL_VARS_INDEX)
          Signature getUsedChannels() = getSignatureList().get(USED_CHANNELS_INDEX)
          -->           
          <xs:element ref="CIRCUS:SignatureList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="CIRCUS:CommunicationList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSetList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSetList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Term annotation complex types -->
  
  <xs:complexType name="CircusAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann"/>            
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ProofObligationAnn">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAnn">            
         <xs:sequence>
           <xs:element ref="Z:Pred"/>
         </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionSignatureAnn">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAnn">            
        <xs:sequence>
          <xs:element ref="CIRCUS:ActionSignature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>        
    </xs:complexContent>
  </xs:complexType>    
  
  <xs:complexType name="ProcessSignatureAnn">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAnn">            
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessSignature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>        
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="StateUpdateAnn">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAnn">
        <xs:sequence>
          <xs:element ref="CIRCUS:StateUpdate">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
</xs:schema>
