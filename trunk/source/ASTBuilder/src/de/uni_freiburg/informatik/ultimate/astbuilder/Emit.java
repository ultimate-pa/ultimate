package de.uni_freiburg.informatik.ultimate.astbuilder;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

public class Emit {
	private static List<String> sBoolPrefixes = Arrays.asList("is", "has");

	protected PrintWriter mWriter;
	protected Grammar mGrammar;
	protected HashSet<String> mEnumTypes;

	public Emit() {
		mEnumTypes = new HashSet<String>();
	}

	public void setGrammar(Grammar grammar) {
		this.mGrammar = grammar;
	}

	public static String capitalize(String str) {
		return Character.toTitleCase(str.charAt(0)) + str.substring(1);
	}

	public static String uncapitalize(String str) {
		return Character.toLowerCase(str.charAt(0)) + str.substring(1);
	}

	public static String breakWords(String str) {
		StringBuffer sb = new StringBuffer();
		int len = str.length();
		for (int i = 0; i < len; i++) {
			char c = str.charAt(i);
			if (Character.isUpperCase(c) || Character.isTitleCase(c)) {
				if (i > 0)
					sb.append(' ');
				sb.append(Character.toLowerCase(c));
			} else
				sb.append(c);
		}
		return sb.toString();
	}

	public static String buildFieldComment(String className, String name, String type) {
		if (type.equals("boolean") && name.length() >= 3 && name.startsWith("is")
				&& (Character.isUpperCase(name.charAt(2)) || Character.isTitleCase(name.charAt(2))))
			return "True iff this " + breakWords(className) + " " + breakWords(name) + ".";
		return "The " + breakWords(name) + " of this " + breakWords(className) + ".";
	}

	public static String buildClassComment(String name, String parent) {
		StringBuffer sb = new StringBuffer("Represents a ");
		sb.append(breakWords(name));
		if (parent != null)
			sb.append(" which is a special form of a ").append(Emit.breakWords(parent));
		sb.append('.');
		return sb.toString();
	}

	private static String getShortComment(String comment) {
		int end = comment.indexOf('.') + 1;
		if (end == 0)
			end = comment.length();
		return comment.substring(0, end);
	}

	protected static void formatComment(PrintWriter writer, String indent, String comment) {
		writer.println(indent + "/**");
		int nl = comment.indexOf('\n');
		while (nl >= 0) {
			writer.println(indent + " * " + comment.substring(0, nl));
			comment = comment.substring(nl + 1);
			nl = comment.indexOf('\n');
		}
		writer.println(indent + " * " + comment);
		writer.println(indent + " */");
	}

	public void emitClasses() throws IOException {
		for (Node n : mGrammar.getNodeTable().values()) {
			String name = n.getName();
			System.err.println("Building: " + name);
			mWriter = new PrintWriter(new FileWriter(name + ".java"));
			emitNode(n);
			mWriter.close();
			mWriter = null;
		}
	}

	public void emitPreamble(Node node) throws IOException {
		String name = node.getName();
		mWriter.println("/* " + name + " -- Automatically generated by TreeBuilder */");
		mWriter.println();
		String pkgName = mGrammar.getPackageName();
		if (pkgName.length() > 0)
			mWriter.println("package " + pkgName + ";");
		for (String importStr : mGrammar.getImports()) {
			if (!importStr.endsWith(".*")) {
				boolean found = false;
				Node ancestor = node;
				while (!found && ancestor != null) {
					/* Check if type is used */
					int dotIndex = importStr.lastIndexOf('.');
					String type = importStr.substring(dotIndex + 1);
					if (ancestor.getUsedTypes().contains(type))
						found = true;
					ancestor = ancestor.getParent();
				}
				if (!found)
					continue;
			}
			mWriter.println("import " + importStr + ";");
		}
		mWriter.println();
	}

	public void emitClassDeclaration(Node node) throws IOException {
		mWriter.println("public " + (node.isAbstract() ? "abstract " : "") + "class " + node.getName()
				+ (node.getParent() != null ? " extends " + node.getParent().getName() : "")
				+ (node.getInterfaces() != null ? " implements " + node.getInterfaces() : "") + " {");
	}

	public String getConstructorParam(Node node, boolean optional) {
		if (node == null) {
			return "";
		}

		StringBuffer sb = new StringBuffer();

		sb.append(getConstructorParam(node.getParent(), optional));

		String comma = "";
		if (sb.length() > 0)
			comma = ", ";

		for (Parameter parameter : node.getParameters()) {
			if (optional || !parameter.isOptional()) {
				String pname = parameter.getName();
				sb.append(comma).append(pname);
				comma = ", ";
			}
		}
		return sb.toString();

	}

	protected void fillConstructorParamComment(Node node, StringBuffer param, StringBuffer comment, boolean optional) {
		Node parent = node.getParent();
		if (parent != null) {
			fillConstructorParamComment(parent, param, comment, optional);
		}
		String comma = "";
		if (param.length() > 0)
			comma = ", ";
		for (Parameter parameter : node.getParameters()) {
			if (optional || !parameter.isOptional()) {
				String pname = parameter.getName();
				String pcomment = uncapitalize(getShortComment(parameter.getComment()));
				comment.append("\n@param ").append(pname).append(' ').append(pcomment);
				param.append(comma);
				param.append(parameter.getType()).append(' ').append(pname);
				comma = ", ";
			}
		}
	}

	public void emitConstructor(Node node, boolean optional) throws IOException {
		String name = node.getName();
		String parentParams = getConstructorParam(node.getParent(), optional);

		StringBuffer constructorParams = new StringBuffer();
		StringBuffer constructorComment = new StringBuffer("The constructor taking initial values.");
		fillConstructorParamComment(node, constructorParams, constructorComment, optional);
		formatComment(mWriter, "    ", constructorComment.toString());

		mWriter.println("    public " + name + "(" + constructorParams.toString() + ") {");
		if (parentParams != null) {
			mWriter.println("        super(" + parentParams + ");");
		}
		for (Parameter parameter : node.getParameters()) {
			if (optional || !parameter.isOptional()) {
				String pname = parameter.getName();
				mWriter.println("        this." + pname + " = " + pname + ";");
			}
		}
		mWriter.println("    }");
		mWriter.println();
	}

	public void emitConstructors(Node node) throws IOException {
		int numNotWriteableParams = 0;
		int numNotOptionalParams = 0;
		int numTotalParams = 0;

		/* Default constructor is only emitted if all fields are writeable */
		/* Optional constructor is only emitted if there are optional fields */
		Node ancestor = node;
		while (ancestor != null) {
			for (Parameter p : ancestor.parameters) {
				numTotalParams++;
				if (!p.isWriteable())
					numNotWriteableParams++;
				if (!p.isOptional())
					numNotOptionalParams++;
			}
			ancestor = ancestor.getParent();
		}
		if (numNotOptionalParams == 0 || numNotWriteableParams == 0) {
			formatComment(mWriter, "    ", "The default constructor.");
			mWriter.println("    public " + node.getName() + "() {");
			mWriter.println("    }");
			mWriter.println();
		}

		if (numNotOptionalParams > 0 && numNotOptionalParams < numTotalParams)
			emitConstructor(node, false);
		if (numTotalParams > 0)
			emitConstructor(node, true);
	}

	void emitArrayToStringCode(String name, String type, String indent, int level) {
		String ivar = "i" + level;
		type = type.substring(0, type.length() - 2);
		String newindent = indent + "        ";
		mWriter.println(indent + "if (" + name + " == null) {");
		mWriter.println(indent + "    sb.append(\"null\");");
		mWriter.println(indent + "} else {");
		mWriter.println(indent + "    sb.append('[');");
		mWriter.println(indent + "    for(int " + ivar + " = 0; " + ivar + " < " + name + ".length; " + ivar + "++) {");
		mWriter.println(newindent + "if (" + ivar + " > 0) sb.append(',');");
		name += "[" + ivar + "]";
		if (type.endsWith("[]"))
			emitArrayToStringCode(name, type, newindent, level + 1);
		else
			mWriter.println(newindent + "    sb.append(" + name + ");");
		mWriter.println(indent + "    }");
		mWriter.println(indent + "    sb.append(']');");
		mWriter.println(indent + "}");
	}

	public void emitNodeHook(Node node) throws IOException {
	}

	public void emitNode(Node node) throws IOException {
		String name = node.getName();
		Parameter[] parameters = node.getParameters();

		emitPreamble(node);

		formatComment(mWriter, "", node.getComment());
		emitClassDeclaration(node);

		if (parameters != null && parameters.length > 0) {
			/* collect enum types */
			for (int i = 0; i < parameters.length; i++) {
				String ptype = parameters[i].getType();
				if (ptype.startsWith("!")) {
					/* java 1.5 enum types */
					int nextComma = ptype.indexOf(',', 1);
					if (nextComma == -1)
						nextComma = ptype.length();
					String enumName = ptype.substring(1, nextComma);
					mWriter.println("    public enum " + enumName + " {");
					StringBuilder sb = new StringBuilder();
					sb.append("        ");
					String comma = "";
					ptype = ptype.substring(nextComma);
					while (ptype.length() > 0) {
						nextComma = ptype.indexOf(',', 1);
						if (nextComma == -1)
							nextComma = ptype.length();
						sb.append(comma);
						if (sb.length() + nextComma > 80) {
							mWriter.println(sb.toString());
							sb = new StringBuilder();
							sb.append("        ");
						}
						sb.append(ptype.substring(1, nextComma));
						comma = ", ";
						ptype = ptype.substring(nextComma);
					}
					mWriter.println(sb.toString());
					mWriter.println("    }");
					mWriter.println();
					parameters[i].setType(enumName);
					mEnumTypes.add(enumName);
				} else if (ptype.startsWith(",")) {
					int idx = 0;
					while (ptype.length() > 0) {
						int nextComma = ptype.indexOf(',', 1);
						if (nextComma == -1)
							nextComma = ptype.length();
						String enumeration = ptype.substring(1, nextComma);
						mWriter.println("    public final static int " + enumeration + " = " + (idx++) + ";");
						ptype = ptype.substring(nextComma);
					}
					mWriter.println();
					parameters[i].setType("int");
				}
			}

			for (int i = 0; i < parameters.length; i++) {
				formatComment(mWriter, "    ", parameters[i].getComment());
				mWriter.println("    " + parameters[i].getType() + " " + parameters[i].getName() + ";");
				mWriter.println();
			}
		}

		emitConstructors(node);

		String toStringComment = "Returns a textual description of this object.";
		formatComment(mWriter, "    ", toStringComment);
		mWriter.println("    public String toString() {");
		if (parameters != null && parameters.length > 0) {
			mWriter.println("        StringBuffer sb = new StringBuffer();");
			mWriter.println("        sb.append(\"" + name + "\").append('[');");
			String comma = "";
			for (int i = 0; i < parameters.length; i++) {
				String pname = parameters[i].getName();
				String ptype = parameters[i].getType();
				if (ptype.endsWith("[]")) {
					if (comma != "")
						mWriter.println("        sb" + comma + ";");
					emitArrayToStringCode(pname, ptype, "        ", 1);
				} else
					mWriter.println("        sb" + comma + ".append(" + pname + ");");
				comma = ".append(',')";
			}
			mWriter.println("        return sb.append(']').toString();");
		} else {
			mWriter.println("        return \"" + name + "\";");
		}
		mWriter.println("    }");

		if (parameters != null && parameters.length > 0) {
			for (int i = 0; i < parameters.length; i++) {
				mWriter.println();

				String pname = parameters[i].getName();
				String ptype = parameters[i].getType();
				String pcomment = parameters[i].getComment();
				String cpname = capitalize(pname);
				String getName = "get" + cpname;
				String setName = "set" + cpname;
				String getComment;
				String setComment;
				if (ptype.equals("boolean")) {
					int j = 0;
					for (String prefix : sBoolPrefixes) {
						if (pname.startsWith(prefix)) {
							j = prefix.length();
							break;
						}
					}
					if (j > 0) {
						getName = pname;
						setName = "set" + pname.substring(j);
					}
					String nonTrueComment = pcomment;
					if (nonTrueComment.startsWith("True "))
						nonTrueComment = nonTrueComment.substring(5);
					getComment = "Checks " + uncapitalize(nonTrueComment) + "\n@return "
							+ uncapitalize(getShortComment(pcomment));
					setComment = "Sets " + uncapitalize(nonTrueComment) + "\n@param " + pname + " "
							+ uncapitalize(getShortComment(pcomment));
				} else {
					getComment = "Gets " + uncapitalize(pcomment) + "\n@return "
							+ uncapitalize(getShortComment(pcomment));
					setComment = "Sets " + uncapitalize(pcomment) + "\n@param " + pname + " "
							+ uncapitalize(getShortComment(pcomment));
				}
				formatComment(mWriter, "    ", getComment);
				mWriter.println("    public " + ptype + " " + getName + "() {");
				mWriter.println("        return " + pname + ";");
				mWriter.println("    }");

				if (parameters[i].isWriteable()) {
					mWriter.println();
					formatComment(mWriter, "    ", setComment);
					mWriter.println("    public void " + setName + "(" + ptype + " " + pname + ") {");
					if (parameters[i].isWriteableOnce) {
						mWriter.println("        //Writeable only once");
						mWriter.println("        if(this." + pname + " != null && " + pname + " != this." + pname
								+ "){");
						mWriter.println("                throw new AssertionError(\"Value is only writeable once\");");
						mWriter.println("        }");
					}
					mWriter.println("        this." + pname + " = " + pname + ";");
					mWriter.println("    }");
				}
			}
		}
		emitNodeHook(node);
		mWriter.println("}");
		mWriter.close();
	}

}
