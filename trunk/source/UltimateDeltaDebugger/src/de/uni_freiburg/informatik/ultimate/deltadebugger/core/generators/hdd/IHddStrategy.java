/*
 * Copyright (C) 2016 University of Freiburg
 *
 * This file is part of the Ultimate Delta Debugger plug-in.
 *
 * The Ultimate Delta Debugger plug-in is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The Ultimate Delta Debugger plug-in is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with the Ultimate Delta Debugger plug-in. If not, see <http://www.gnu.org/licenses/>.
 *
 * Additional permission under GNU GPL version 3 section 7:
 * If you modify the Ultimate Delta Debugger plug-in, or any covered work, by linking
 * or combining it with Eclipse RCP (or a modified version of Eclipse RCP),
 * containing parts covered by the terms of the Eclipse Public License, the
 * licensors of the Ultimate Delta Debugger plug-in grant you additional permission
 * to convey the resulting work.
 */
package de.uni_freiburg.informatik.ultimate.deltadebugger.core.generators.hdd;

import de.uni_freiburg.informatik.ultimate.deltadebugger.core.IVariantGenerator;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.generators.hdd.changes.ChangeCollector;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.parser.pst.interfaces.IPSTNode;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.parser.pst.interfaces.IPSTProtectedRegion;

/**
 * Strategy for the HDD inspired pass that controls if and how nodes of the tree are changed.
 */
@FunctionalInterface
public interface IHddStrategy {
	/**
	 * Allows to add changes that are not directly related to a child node, for instance individual tokens. In fact, the
	 * generated changes should not overlap any change generated for a child.
	 *
	 * @param node
	 *            PST node
	 * @param changeCollector
	 *            collector of changes
	 */
	default void createAdditionalChangesForExpandedNode(final IPSTNode node, final ChangeCollector changeCollector) {
		// no default behavior required
	}
	
	/**
	 * Create the change for node. If it can be applied, the subtree is not considered anymore. Otherwise it will be
	 * expanded, i.e. a change for each child will be created.
	 *
	 * @param node
	 *            PST node
	 * @param changeCollector
	 *            collector of changes
	 */
	void createChangeForNode(IPSTNode node, ChangeCollector changeCollector);
	
	/**
	 * Determines if the changes generated by the node will be tested with other changes on the same level or not.
	 * If true is returned for a node, all changes that are generated for the children of this node (not the node
	 * itself!) will have their own {@link IVariantGenerator} instance and will effectively be search on their own.<br>
	 * Example: Returning true for function definition bodies causes that each body compound statement is reduced
	 * individually instead of together with all other nodes on the same level. The search tree may become wider.
	 *
	 * @param node
	 *            PST node
	 * @return whether the changes created by expanding node will be returned searched individually
	 */
	default boolean expandIntoOwnGroup(final IPSTNode node) {
		return false;
	}
	
	/**
	 * Determines if a node without changes will be expanded immediately instead on the next level.
	 * The search tree depth may be reduced.
	 *
	 * @param node
	 *            PST node
	 * @return wether changes for children should take the place immediately if no changes are generated for node
	 */
	default boolean expandUnchangeableNodeImmediately(final IPSTNode node) {
		return false;
	}
	
	/**
	 * Determines if a subtree starting at node is processed or skipped.
	 *
	 * @param node
	 *            PST node
	 * @return whether the full subtree starting at node will be skipped
	 */
	default boolean skipSubTree(final IPSTNode node) {
		return node instanceof IPSTProtectedRegion;
	}
}
