/*
 * Copyright (C) 2016 University of Freiburg
 *
 * This file is part of the Ultimate Delta Debugger plug-in.
 *
 * The Ultimate Delta Debugger plug-in is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The Ultimate Delta Debugger plug-in is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with the Ultimate Delta Debugger plug-in. If not, see <http://www.gnu.org/licenses/>.
 *
 * Additional permission under GNU GPL version 3 section 7:
 * If you modify the Ultimate Delta Debugger plug-in, or any covered work, by linking
 * or combining it with Eclipse RCP (or a modified version of Eclipse RCP),
 * containing parts covered by the terms of the Eclipse Public License, the
 * licensors of the Ultimate Delta Debugger plug-in grant you additional permission
 * to convey the resulting work.
 */
package de.uni_freiburg.informatik.ultimate.deltadebugger.core.parser.pst;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import de.uni_freiburg.informatik.ultimate.acsl.parser.ACSLSyntaxErrorException;
import de.uni_freiburg.informatik.ultimate.acsl.parser.Parser;
import de.uni_freiburg.informatik.ultimate.core.model.services.ILogger;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.parser.pst.implementation.PSTACSLNode;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.parser.pst.interfaces.IPSTACSLComment;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.parser.pst.interfaces.IPSTACSLNode;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.parser.pst.interfaces.IPSTNode;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.text.HierarchicalSourceRangeComparator;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.text.ISourceDocument;
import de.uni_freiburg.informatik.ultimate.deltadebugger.core.text.ISourceRange;
import de.uni_freiburg.informatik.ultimate.model.acsl.ACSLNode;
import de.uni_freiburg.informatik.ultimate.model.acsl.ACSLNode.ACSLSourceLocation;

/**
 * Creates a PST nodes from an ACSL-AST.
 */
class ACSLCommentParser {
	private final IPSTACSLComment mAcslComment;
	private final boolean mInGlobalScope;
	private final ISourceDocument mSource;
	private final ILogger mLogger;

	/**
	 * Create instance to handle a particular ACSL comment.
	 * 
	 * @param acslComment
	 *            the ACSL comment
	 * @param inGlobalScope
	 *            parse as global or function local comment
	 * @param logger
	 *            logger
	 */
	public ACSLCommentParser(final IPSTACSLComment acslComment, final boolean inGlobalScope, final ILogger logger) {
		mAcslComment = acslComment;
		mInGlobalScope = inGlobalScope;
		mSource = acslComment.getSource();
		mLogger = logger;
	}

	/**
	 * Parse the ACSL comment and create a tree of IPSTACSLNodes.
	 * 
	 * @return the tree of IPSTACSLNodes or null of parsing or a source location consistency check failed.
	 */
	public IPSTACSLNode parseAndCreatePst() {
		final ACSLNode acslRootNode = parseCommentText();
		if (acslRootNode == null) {
			return null;
		}
		return createAcslTree(acslRootNode);
	}

	/**
	 * Creates PSTACSLNodes for the whole tree of ACSLNodes (but does not add them to the ACSLComment node) The ACSLNode
	 * structure is not closely related to the source syntax. The ACSLVisitor and ACSLTransformer only support a
	 * top-down traversal and no bottom-up traversal, and they visit nodes twice, so there is no simple copy of the tree
	 * structure possible by using those. Additionally, not every child returned by getChildren() is actually an
	 * ACSLNode generated by the parser from some source text. Every child that is not an ACSLNode or has not valid
	 * location is skipped. The following is an attempt to make the best out of the given ACSL-AST by just taking nodes
	 * that have an exact source location attached. I'm not sure if the order of children actually corresponds to that
	 * of the source text, even if location information is available, so all potential children are sorted and validated
	 * to be in inside the parent node's range before creating a PST node.
	 * 
	 * @param acslRootNode
	 *            root ACSL node created by the parser
	 * @return IPSTACSLNode corresponding to the given root node, or null if not within comment bounds
	 */
	private IPSTACSLNode createAcslTree(final ACSLNode acslRootNode) {
		// Convert the root node, which has to respect the bounds of the comment itself
		final List<IPSTACSLNode> listOfRootNode = createChildNodes(mAcslComment, Arrays.asList(acslRootNode));

		// Convert all ACSL children recursively
		final Deque<IPSTACSLNode> nodesToExpand = new ArrayDeque<>(listOfRootNode);
		while (!nodesToExpand.isEmpty()) {
			final IPSTACSLNode node = nodesToExpand.pollFirst();
			final List<IPSTACSLNode> children = createChildNodes(node, node.getAcslNode().getOutgoingNodes());
			children.stream().forEachOrdered(node::addChild);
			nodesToExpand.addAll(children);
		}

		return listOfRootNode.isEmpty() ? null : listOfRootNode.get(0);
	}

	private List<IPSTACSLNode> createChildNodes(final IPSTNode parent, final List<ACSLNode> acslChildren) {
		// Create PST nodes for all children with valid location information.
		// Sort them and remove nodes that overlap the right sibling or the parent nodes location, just to be safe.
		final List<IPSTACSLNode> children = acslChildren.stream().filter(n -> n.getLocation().getStartLine() != -1)
				.map(this::createPreliminaryPstNode).sorted(HierarchicalSourceRangeComparator.getInstance())
				.collect(Collectors.toCollection(ArrayList::new));

		final Iterator<IPSTACSLNode> iter = children.iterator();
		IPSTACSLNode prevNode = null;
		while (iter.hasNext()) {
			final IPSTACSLNode node = iter.next();
			// not inside parent?
			if (!parent.contains(node)) {
				mLogger.info("Skipping ACSL child node " + node + " that is not inside parent " + parent);
				iter.remove();
				continue;
			}

			// overlapped by left sibling?
			if (prevNode != null && prevNode.endOffset() > node.offset()) {
				mLogger.info("Skipping ACSL child node " + node + " which overlaps left sibling " + prevNode);
				iter.remove();
				continue;
			}

			prevNode = node;
		}
		return children;
	}

	private IPSTACSLNode createPreliminaryPstNode(final ACSLNode acslNode) {
		final ACSLSourceLocation acslLocation = acslNode.getLocation();
		final ISourceRange sourceLocation = mSource.newSourceRange(
				mSource.getLineOffset(acslLocation.getStartLine()) + acslLocation.getStartColumn(),
				mSource.getLineOffset(acslLocation.getEndLine()) + acslLocation.getEndColumn());
		return new PSTACSLNode(mSource, sourceLocation, acslNode);
	}

	private ACSLNode parseCommentText() {
		// The parsing is different for ACSL in the global scope and inside function bodies.
		// A line with a special keyword is prepended to the parser input to select the corresponding production.
		// Additionally the comment text is added without comment delimiters.
		final StringBuilder input = new StringBuilder();
		input.append(mInGlobalScope ? "gstart\n" : "lstart\n");
		input.append(mAcslComment.getSource().getText(mAcslComment.offset() + 2,
				mAcslComment.endOffset() - (mAcslComment.getAstNode().isBlockComment() ? 2 : 0)));

		// It's not really a problem in this context, when parsing fails. We just parse what we can and ignore the rest.
		// Syntax errors during delta debugging may actually be very expected, so the logging
		// may have to be removed to reduce log spam.
		try {
			return Parser.parseComment(input.toString(), mAcslComment.getStartingLineNumber(),
					mSource.getColumnNumber(mAcslComment.offset()) + 2 - 1, mLogger);
		} catch (final ACSLSyntaxErrorException e) {
			mLogger.error("Syntax error when parsing ACSL comment " + mAcslComment, e);
		} catch (final Exception e) {
			mLogger.error("Exception when parsing ACSL comment " + mAcslComment, e);
		}
		return null;
	}
}
