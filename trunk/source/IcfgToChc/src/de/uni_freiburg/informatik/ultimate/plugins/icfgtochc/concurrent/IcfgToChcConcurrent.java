package de.uni_freiburg.informatik.ultimate.plugins.icfgtochc.concurrent;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import de.uni_freiburg.informatik.ultimate.automata.partialorder.independence.IIndependenceRelation;
import de.uni_freiburg.informatik.ultimate.automata.partialorder.independence.IIndependenceRelation.Dependence;
import de.uni_freiburg.informatik.ultimate.lib.chc.HcBodyVar;
import de.uni_freiburg.informatik.ultimate.lib.chc.HcHeadVar;
import de.uni_freiburg.informatik.ultimate.lib.chc.HcPredicateSymbol;
import de.uni_freiburg.informatik.ultimate.lib.chc.HcSymbolTable;
import de.uni_freiburg.informatik.ultimate.lib.chc.HcVar;
import de.uni_freiburg.informatik.ultimate.lib.chc.HornClause;
import de.uni_freiburg.informatik.ultimate.lib.modelcheckerutils.cfg.CfgSmtToolkit;
import de.uni_freiburg.informatik.ultimate.lib.modelcheckerutils.cfg.IIcfgSymbolTable;
import de.uni_freiburg.informatik.ultimate.lib.modelcheckerutils.cfg.structure.IIcfgTransition;
import de.uni_freiburg.informatik.ultimate.lib.modelcheckerutils.cfg.structure.IcfgLocation;
import de.uni_freiburg.informatik.ultimate.lib.modelcheckerutils.cfg.transitions.TransFormula;
import de.uni_freiburg.informatik.ultimate.lib.modelcheckerutils.cfg.variables.IProgramVar;
import de.uni_freiburg.informatik.ultimate.lib.smtlibutils.ManagedScript;
import de.uni_freiburg.informatik.ultimate.lib.smtlibutils.SmtSortUtils;
import de.uni_freiburg.informatik.ultimate.lib.smtlibutils.SmtUtils;
import de.uni_freiburg.informatik.ultimate.lib.smtlibutils.Substitution;
import de.uni_freiburg.informatik.ultimate.logic.Script;
import de.uni_freiburg.informatik.ultimate.logic.Sort;
import de.uni_freiburg.informatik.ultimate.logic.Term;
import de.uni_freiburg.informatik.ultimate.logic.TermVariable;
import de.uni_freiburg.informatik.ultimate.util.datastructures.BidirectionalMap;
import de.uni_freiburg.informatik.ultimate.util.datastructures.relation.NestedMap2;
import de.uni_freiburg.informatik.ultimate.util.datastructures.relation.Pair;

/**
 * Class to create horn-clauses for given edges to create thread-modular proofs.
 *
 * @author Frank Sch√ºssele (schuessf@informatik.uni-freiburg.de)
 *
 */
public class IcfgToChcConcurrent {
	private static final String FUNCTION_NAME = "Inv";

	private final ManagedScript mManagedScript;

	// maps a procedure name and a location (in the procedure) to an integer, such that the location variable has this
	// integer as value iff control is in the given location
	private final NestedMap2<String, IcfgLocation, Integer> mLocationIndices = new NestedMap2<>();

	// maps each thread template (identified by procedure name) to the number of instances
	private final Map<String, Integer> mNumberOfThreads;

	// used as location for threads that are not currently running
	private final Term mBottomLocation;

	private final HcPredicateSymbol mPredicate;
	private final HcSymbolTable mHcSymbolTable;

	// list of "head vars" (?), in the order as given to the CHC predicate
	// these variables are always used in the head of any clause generated by this class
	private final List<HcHeadVar> mDefaultHeadVars;

	private final NestedMap2<String, Integer, HcSleepVar> mSleepVars = new NestedMap2<>();
	private final NestedMap2<String, Integer, HcLocationVar> mLocationsVars = new NestedMap2<>();
	private final NestedMap2<String, Integer, HcThreadIdVar> mIdVars = new NestedMap2<>();

	private final Map<String, Collection<IcfgLocation>> mThreadLocations;

	/**
	 * maps a number i to the variable used for the i-th argument of the CHC predicate
	 */
	private final BidirectionalMap<Integer, IHcReplacementVar> mPositions2Vars = new BidirectionalMap<>();

	private final IIndependenceRelation<?, ? super IIcfgTransition<?>> mIndependence;

	/**
	 *
	 * @param numberOfThreads
	 *            Maps thread names to the number of instances to include in the Horn clause system
	 * @param managedScript
	 * @param cfgSmtToolkit
	 * @param hcSymbolTable
	 * @param variableFilter
	 *
	 */
	public IcfgToChcConcurrent(final Map<String, Integer> numberOfThreads, final ManagedScript managedScript,
			final CfgSmtToolkit cfgSmtToolkit, final HcSymbolTable hcSymbolTable,
			final Predicate<IProgramVar> variableFilter, final Map<String, Collection<IcfgLocation>> threadLocations,
			final IIndependenceRelation<?, ? super IIcfgTransition<?>> independence) {
		final IIcfgSymbolTable symbolTable = cfgSmtToolkit.getSymbolTable();
		mHcSymbolTable = hcSymbolTable;
		mManagedScript = managedScript;
		final List<IProgramVar> globalVariables =
				symbolTable.getGlobals().stream().filter(variableFilter).collect(Collectors.toList());
		mNumberOfThreads = new LinkedHashMap<>(numberOfThreads);
		mBottomLocation = numeral(-1);
		mThreadLocations = threadLocations;
		mIndependence = independence;

		final Map<String, List<IProgramVar>> localVariables = new HashMap<>();
		for (final String proc : mNumberOfThreads.keySet()) {
			localVariables.put(proc,
					symbolTable.getLocals(proc).stream().filter(variableFilter).collect(Collectors.toList()));
		}
		initializeDefaultVars(globalVariables, localVariables);

		final List<Sort> sorts = IntStream.range(0, mPositions2Vars.size())
				.mapToObj(x -> mPositions2Vars.get(x).getSort()).collect(Collectors.toList());
		mPredicate = hcSymbolTable.getOrConstructHornClausePredicateSymbol(FUNCTION_NAME, sorts);

		mDefaultHeadVars = IntStream.range(0, mPositions2Vars.size())
				.mapToObj(x -> constructHeadVar(mPositions2Vars.get(x), x)).collect(Collectors.toList());
	}

	private HcHeadVar constructHeadVar(final IHcReplacementVar rv, final int index) {
		return mHcSymbolTable.getOrConstructHeadVar(mPredicate, index, rv.getSort(), rv);
	}

	private void initializeDefaultVars(final Collection<IProgramVar> globalVariables,
			final Map<String, List<IProgramVar>> localVariables) {
		int i = 0;
		for (final IProgramVar v : globalVariables) {
			mPositions2Vars.put(i, new HcGlobalVar(v));
			i++;
		}
		for (final Entry<String, Integer> entry : mNumberOfThreads.entrySet()) {
			final String proc = entry.getKey();
			final List<IProgramVar> localVars = localVariables.get(proc);
			for (int j = 0; j < entry.getValue(); j++) {
				// thread ID
				final var id = new HcThreadIdVar(getScript(), proc, j);
				mIdVars.put(proc, j, id);
				mPositions2Vars.put(i, id);
				i++;

				// Location
				final var loc = new HcLocationVar(proc, j, getIntSort());
				mLocationsVars.put(proc, j, loc);
				mPositions2Vars.put(i, loc);
				i++;

				// sleep set
				final var sleep = new HcSleepVar(getScript(), proc, j);
				mSleepVars.put(proc, j, sleep);
				mPositions2Vars.put(i, sleep);
				i++;

				for (final IProgramVar v : localVars) {
					mPositions2Vars.put(i, new HcLocalVar(v, j));
					i++;
				}
			}
		}
	}

	private Sort getIntSort() {
		return SmtSortUtils.getIntSort(getScript());
	}

	private List<Term> getDefaultArgs() {
		return mDefaultHeadVars.stream().map(HcVar::getTerm).collect(Collectors.toList());
	}

	private Term numeral(final long n) {
		return getScript().numeral(BigInteger.valueOf(n));
	}

	private Script getScript() {
		return mManagedScript.getScript();
	}

	private Term getLocIndexTerm(final IcfgLocation loc, final String proc) {
		Integer index = mLocationIndices.get(proc, loc);
		if (index == null) {
			final Map<IcfgLocation, Integer> otherIndices = mLocationIndices.get(proc);
			index = otherIndices == null ? 0 : otherIndices.size();
			mLocationIndices.put(proc, loc, index);
		}
		return numeral(index);
	}

	// pc_0 = l_0 -> Inv(pc_0, ...)
	public HornClause getInitialClause(final Collection<IcfgLocation> initialLocations) {
		final NestedMap2<String, Integer, Term> locationMap = new NestedMap2<>();
		for (final Entry<String, Integer> entry : mNumberOfThreads.entrySet()) {
			for (int i = 0; i < entry.getValue(); i++) {
				locationMap.put(entry.getKey(), i, mBottomLocation);
			}
		}
		for (final IcfgLocation loc : initialLocations) {
			final String proc = loc.getProcedure();
			for (int i = 0; i < mNumberOfThreads.get(proc); i++) {
				locationMap.put(proc, i, getLocIndexTerm(loc, proc));
			}
		}
		final var locConstraint = getConstraintFromLocationMap(locationMap);

		final var idConstraints = new ArrayList<Term>();
		// final var instances = mNumberOfThreads.entrySet().stream()
		// .flatMap(e -> IntStream.range(0, e.getValue()).mapToObj(i -> new Pair<>(e.getKey(), i)))
		// .collect(Collectors.toList());
		// for (int i = 0; i < instances.size(); ++i) {
		// final var first = instances.get(i);
		// final var firstIndex =
		// mPositions2Vars.inverse().get(new HcThreadIdVar(getScript(), first.getKey(), first.getValue()));
		// final var firstId = mDefaultHeadVars.get(firstIndex);
		//
		// for (int j = i + 1; j < instances.size(); ++j) {
		// final var second = instances.get(j);
		// final var secondIndex = mPositions2Vars.inverse()
		// .get(new HcThreadIdVar(getScript(), second.getKey(), second.getValue()));
		// final var secondId = mDefaultHeadVars.get(secondIndex);
		//
		// idConstraints.add(SmtUtils.distinct(getScript(), firstId.getTerm(), secondId.getTerm()));
		// }
		// }

		// sleep set initially empty
		final var sleepConstraints = mSleepVars.values()
				.map(sv -> SmtUtils.binaryEquality(getScript(),
						mDefaultHeadVars.get(mPositions2Vars.inverse().get(sv)).getTerm(), numeral(0)))
				.collect(Collectors.toList());

		return constructHornClause(SmtUtils.and(getScript(), locConstraint, SmtUtils.and(getScript(), sleepConstraints),
				SmtUtils.and(getScript(), idConstraints)), List.of(), Set.of());
	}

	/**
	 * Constructs a Horn clause with a given body and the default head.
	 *
	 * @param constraint
	 *            The SMT constraint in the clause body
	 * @param bodyArguments
	 *            Each list of terms is used as arguments for an invocation of {@link #mPredicate} in the body
	 * @param bodyVars
	 *            Variables used in the bodyArguments. These will be universally quanmBodyVariablestified in the clause.
	 * @return A Horn clause with a body built from the given arguments, and a head consisting of an {@link #mPredicate}
	 *         invocation with the default variables ({@link #mDefaultHeadVars}).
	 */
	private HornClause constructHornClause(final Term constraint, final List<List<Term>> bodyArguments,
			final Set<HcVar> bodyVars) {
		return new HornClause(mManagedScript, mHcSymbolTable, constraint, mPredicate, mDefaultHeadVars,
				Collections.nCopies(bodyArguments.size(), mPredicate), bodyArguments, bodyVars);
	}

	/**
	 * Constructs a constraint that specifies control locations.
	 *
	 * @param locationMap
	 *            A map from thread template (i.e. procedure name) and instance number to a term representing the
	 *            respective location.
	 * @return A conjunction of equalities between the default variables for control locations
	 *         ({@link #mDefaultHeadVars}) and the locations specified by the map
	 */
	private Term getConstraintFromLocationMap(final NestedMap2<String, Integer, Term> locationMap) {
		final List<Term> constraints = new ArrayList<>();
		for (final var triple : locationMap.entrySet()) {
			final var constraint = getLocationConstraint(triple.getFirst(), triple.getSecond(), triple.getThird());
			constraints.add(constraint);
		}
		return SmtUtils.and(getScript(), constraints);
	}

	/**
	 * Constructs a constraint that specifies a single control location.
	 *
	 * @return Equality between the default variable for the given thread's control location ({@link #mDefaultHeadVars})
	 *         and the given location term
	 */
	private Term getLocationConstraint(final String proc, final int threadInstance, final Term location) {
		final HcLocationVar locVar = new HcLocationVar(proc, threadInstance, getIntSort());
		final int index = mPositions2Vars.inverse().get(locVar);
		final Term term = mDefaultHeadVars.get(index).getTerm();
		return SmtUtils.binaryEquality(getScript(), term, location);
	}

	// list of clauses of the form
	// Inv(..., pc_i, ...) /\ pc_i = l_err -> false
	public Collection<HornClause> getSafetyClauses(final Collection<IcfgLocation> errorLocations) {
		final List<HornClause> result = new ArrayList<>();
		final Set<HcVar> vars = new HashSet<>(mDefaultHeadVars);
		final List<Term> bodyArgs = getDefaultArgs();
		for (final IcfgLocation loc : errorLocations) {
			final String proc = loc.getProcedure();
			for (int i = 0; i < mNumberOfThreads.get(proc); i++) {
				final Term constraint = getLocationConstraint(proc, i, getLocIndexTerm(loc, proc));
				result.add(new HornClause(mManagedScript, mHcSymbolTable, constraint, List.of(mPredicate),
						List.of(bodyArgs), vars));
			}
		}
		return result;
	}

	/**
	 *
	 * @param procs
	 * @return
	 */
	private List<Map<String, Integer>> getCartesianProductOfIndices(final Collection<String> procs) {
		List<Map<String, Integer>> result = List.of(Map.of());
		for (final String p : procs) {
			final List<Map<String, Integer>> newResult = new ArrayList<>();
			for (int i = 0; i < mNumberOfThreads.get(p); i++) {
				for (final Map<String, Integer> map : result) {
					final Map<String, Integer> newMap = new HashMap<>(map);
					newMap.put(p, i);
					newResult.add(newMap);
				}
			}
			result = newResult;
		}
		return result;
	}

	/**
	 *
	 * @param locations
	 * @param indexMap
	 * @return
	 */
	private NestedMap2<String, Integer, Term> getLocationMap(final Collection<IcfgLocation> locations,
			final Map<String, Integer> indexMap) {
		final NestedMap2<String, Integer, Term> locMap = new NestedMap2<>();
		for (final IcfgLocation loc : locations) {
			final String proc = loc.getProcedure();
			locMap.put(proc, indexMap.get(proc), getLocIndexTerm(loc, proc));
		}
		return locMap;
	}

	/**
	 *
	 * @param pre
	 * @param edge
	 * @param post
	 * @return
	 */
	public Collection<HornClause> getInductivityClauses(final List<IcfgLocation> pre, final IIcfgTransition<?> edge,
			final List<IcfgLocation> post) {
		final String activeProcedure = edge.getPrecedingProcedure();

		final List<HornClause> result = new ArrayList<>();
		final Set<String> containedProcs =
				Stream.concat(pre.stream(), post.stream()).map(IcfgLocation::getProcedure).collect(Collectors.toSet());
		for (final Map<String, Integer> indexMap : getCartesianProductOfIndices(containedProcs)) {
			final NestedMap2<String, Integer, Term> locMapIn = getLocationMap(pre, indexMap);
			final NestedMap2<String, Integer, Term> locMapOut = getLocationMap(post, indexMap);

			final TransFormula transformula = edge.getTransformula();
			final Map<TermVariable, Term> substitution = new HashMap<>();
			final List<Term> constraints = new ArrayList<>();
			final List<Term> bodyArgs = getDefaultArgs();
			final Set<HcVar> bodyVars = new HashSet<>();

			for (final var entry : mPositions2Vars.entrySet()) {
				final int index = entry.getKey();
				final IHcReplacementVar rv = entry.getValue();
				IProgramVar pv = null;
				if (rv instanceof HcLocalVar) {
					final HcLocalVar lv = (HcLocalVar) rv;
					if (!Objects.equals(indexMap.get(lv.getProcedure()), lv.getIndex())) {
						continue;
					}
					pv = lv.getVariable();
				} else if (rv instanceof HcGlobalVar) {
					final HcGlobalVar gv = (HcGlobalVar) rv;
					pv = gv.getVariable();
				} else if (rv instanceof HcLocationVar) {
					final HcLocationVar lv = (HcLocationVar) rv;
					final String procedure = lv.getProcedure();
					final int instanceIndex = lv.getIndex();
					Term locIn = locMapIn.get(procedure, instanceIndex);
					Term locOut = locMapOut.get(procedure, instanceIndex);
					if (locIn == null && locOut == null) {
						continue;
					}
					if (locIn == null) {
						locIn = mBottomLocation;
					}
					if (locOut == null) {
						locOut = mBottomLocation;
					}
					constraints
							.add(SmtUtils.binaryEquality(getScript(), mDefaultHeadVars.get(index).getTerm(), locOut));
					if (!locIn.equals(locOut)) {
						bodyArgs.set(index, locIn);
					}

					// rv does not appear in transition formula, so skip the rest of the loop
					continue;
				} else if (rv instanceof HcSleepVar) {
					final var sv = (HcSleepVar) rv;
					final var activeInstanceIndex = indexMap.get(sv.getThreadTemplateName());
					if (Objects.equals(sv.getInstanceIndex(), activeInstanceIndex)) {
						// this is the sleep variable for the active thread
						final var bv = mHcSymbolTable.getOrConstructBodyVar(mPredicate, index, sv.getSort(), sv);
						bodyVars.add(bv);
						bodyArgs.set(index, bv.getTerm());

						// ensure that the active thread is not sleeping
						constraints.add(SmtUtils.binaryEquality(getScript(), bv.getTerm(), numeral(0)));
					} else {
						final var oldSleep = mHcSymbolTable.getOrConstructBodyVar(mPredicate, index, sv.getSort(), sv);
						bodyVars.add(oldSleep);
						bodyArgs.set(index, oldSleep.getTerm());
						final var newSleep = mDefaultHeadVars.get(index).getTerm();

						final var hcLoc =
								new HcLocationVar(sv.getThreadTemplateName(), sv.getInstanceIndex(), getIntSort());
						final int locIndex = mPositions2Vars.inverse().get(hcLoc);
						final var locVar = mDefaultHeadVars.get(locIndex);

						final var currentId = mDefaultHeadVars.get(mPositions2Vars.inverse()
								.get(new HcThreadIdVar(getScript(), activeProcedure, activeInstanceIndex)));
						final var otherId = mDefaultHeadVars.get(mPositions2Vars.inverse().get(
								new HcThreadIdVar(getScript(), sv.getThreadTemplateName(), sv.getInstanceIndex())));

						// update sleep variable depending on commutativity and thread ID ordering
						final Term nonCommConstr = getNonCommutativityConstraint(sv, locVar.getTerm(), edge);
						constraints
								.add(SmtUtils.binaryBooleanEquality(getScript(),
										SmtUtils.binaryEquality(getScript(), newSleep, numeral(0)),
										SmtUtils.or(getScript(), SmtUtils.and(getScript(),
												SmtUtils.greater(getScript(), otherId.getTerm(), currentId.getTerm()),
												SmtUtils.binaryEquality(getScript(), oldSleep.getTerm(), numeral(0))),
												nonCommConstr)));
					}
					// else if ((activeInstanceIndex != null && sv.getInstanceIndex() < activeInstanceIndex)
					// || (activeInstanceIndex == null
					// && sv.getThreadTemplateName().compareTo(activeProcedure) < 0)) {
					// final var newSleep = mDefaultHeadVars.get(index).getTerm();
					//
					// final var locVar = mLocationsVars.get(sv.getThreadTemplateName(), sv.getInstanceIndex());
					// final var locVarIndex = mPositions2Vars.inverse().get(locVar);
					// final var locVar2 =
					// mHcSymbolTable.getOrConstructBodyVar(mPredicate, locVarIndex, locVar.getSort(), locVar);
					// bodyVars.add(locVar2);
					// bodyArgs.set(locVarIndex, locVar2.getTerm());
					//
					// // set newSleep to true/false depending on commutativity
					// final Term nonCommConstr = getNonCommutativityConstraint(sv, locVar2.getTerm(), edge);
					// constraints.add(SmtUtils.binaryBooleanEquality(getScript(),
					// SmtUtils.binaryEquality(getScript(), newSleep, numeral(0)), nonCommConstr));
					// } else {
					// assert (activeInstanceIndex != null && sv.getInstanceIndex() > activeInstanceIndex)
					// || (activeInstanceIndex == null
					// && sv.getThreadTemplateName().compareTo(activeProcedure) > 0);
					//
					// final var oldSleep = mHcSymbolTable.getOrConstructBodyVar(mPredicate, index, sv.getSort(), sv);
					// bodyVars.add(oldSleep);
					// bodyArgs.set(index, oldSleep.getTerm());
					// final var newSleep = mDefaultHeadVars.get(index).getTerm();
					//
					// final var locVar = mLocationsVars.get(sv.getThreadTemplateName(), sv.getInstanceIndex());
					// final var locVarIndex = mPositions2Vars.inverse().get(locVar);
					// final var locVar2 =
					// mHcSymbolTable.getOrConstructBodyVar(mPredicate, locVarIndex, locVar.getSort(), locVar);
					// bodyVars.add(locVar2);
					// bodyArgs.set(locVarIndex, locVar2.getTerm());
					//
					// // set newSleep to old/false depending on commutativity
					// final Term nonCommConstr = getNonCommutativityConstraint(sv, locVar2.getTerm(), edge);
					// constraints.add(SmtUtils.ite(getScript(), nonCommConstr,
					// SmtUtils.binaryEquality(getScript(), newSleep, numeral(0)),
					// SmtUtils.binaryEquality(getScript(), newSleep, oldSleep.getTerm())));
					// }
					continue;
				} else if (rv instanceof HcThreadIdVar) {
					// nothing to do here: the default argument in the body is already the headVar
					// this is correct, because the thread ID never changes
					continue;
				} else {
					throw new UnsupportedOperationException("Unknown kind of variable: " + rv);
				}

				assert pv != null;
				final TermVariable inVar = transformula.getInVars().get(pv);
				final TermVariable outVar = transformula.getOutVars().get(pv);
				substitution.put(outVar, mDefaultHeadVars.get(index).getTerm());
				if (!Objects.equals(inVar, outVar)) {
					final HcBodyVar bv = mHcSymbolTable.getOrConstructBodyVar(mPredicate, index, pv);
					final Term term = bv.getTerm();
					bodyArgs.set(index, term);
					substitution.put(inVar, term);
					bodyVars.add(bv);
				}
			}

			// add ID constraints
			final var instances = mNumberOfThreads.entrySet().stream()
					.flatMap(e -> IntStream.range(0, e.getValue()).mapToObj(i -> new Pair<>(e.getKey(), i)))
					.collect(Collectors.toList());
			for (int i = 0; i < instances.size(); ++i) {
				final var first = instances.get(i);
				final var firstIndex =
						mPositions2Vars.inverse().get(new HcThreadIdVar(getScript(), first.getKey(), first.getValue()));
				final var firstId = mDefaultHeadVars.get(firstIndex);

				for (int j = i + 1; j < instances.size(); ++j) {
					final var second = instances.get(j);
					final var secondIndex = mPositions2Vars.inverse()
							.get(new HcThreadIdVar(getScript(), second.getKey(), second.getValue()));
					final var secondId = mDefaultHeadVars.get(secondIndex);

					constraints.add(SmtUtils.less(getScript(), firstId.getTerm(), secondId.getTerm()));
				}
			}

			// Replace all other variables with aux-vars
			final Term formula = transformula.getFormula();
			for (final TermVariable v : formula.getFreeVars()) {
				if (substitution.containsKey(v)) {
					continue;
				}
				// TODO: Using the number of bodyVars as index is a hack!
				final HcBodyVar auxVar =
						mHcSymbolTable.getOrConstructBodyVar(mPredicate, bodyVars.size(), v.getSort(), v);
				substitution.put(v, auxVar.getTerm());
				bodyVars.add(auxVar);
			}
			constraints.add(Substitution.apply(mManagedScript, substitution, formula));
			result.add(constructHornClause(SmtUtils.and(getScript(), constraints), List.of(bodyArgs), bodyVars));
		}
		return result;
	}

	private Term getNonCommutativityConstraint(final HcSleepVar sv, final Term locVar,
			final IIcfgTransition<?> currentEdge) {

		final var nonCommLocations = new HashSet<Term>();
		for (final var loc : mThreadLocations.get(sv.getThreadTemplateName())) {
			if (loc.getOutgoingEdges().stream()
					.anyMatch(edge -> mIndependence.isIndependent(null, edge, currentEdge) != Dependence.INDEPENDENT)) {
				nonCommLocations.add(getLocIndexTerm(loc, sv.getThreadTemplateName()));
			}
		}

		nonCommLocations.stream().map(loc -> SmtUtils.binaryEquality(getScript(), locVar, loc))
				.collect(Collectors.toList());
		return SmtUtils.and(getScript(), nonCommLocations.stream()
				.map(loc -> SmtUtils.binaryEquality(getScript(), locVar, loc)).collect(Collectors.toList()));
	}

	public Collection<HornClause> getInductivityClauses(final IIcfgTransition<?> edge) {
		return getInductivityClauses(List.of(edge.getSource()), edge, List.of(edge.getTarget()));
	}

	public HornClause getIdUniquenessClause() {
		final var bodyArgs = getDefaultArgs();
		final var constraints = new ArrayList<Term>();

		final var instances = mNumberOfThreads.entrySet().stream()
				.flatMap(e -> IntStream.range(0, e.getValue()).mapToObj(i -> new Pair<>(e.getKey(), i)))
				.collect(Collectors.toList());

		for (int i = 0; i < instances.size(); ++i) {
			final var first = instances.get(i);
			final var firstIndex =
					mPositions2Vars.inverse().get(new HcThreadIdVar(getScript(), first.getKey(), first.getValue()));
			final var firstId = bodyArgs.get(firstIndex);

			for (int j = i + 1; j < instances.size(); ++j) {
				final var second = instances.get(j);
				final var secondIndex = mPositions2Vars.inverse()
						.get(new HcThreadIdVar(getScript(), second.getKey(), second.getValue()));
				final var secondId = bodyArgs.get(secondIndex);

				constraints.add(SmtUtils.binaryEquality(getScript(), firstId, secondId));
			}
		}

		return new HornClause(mManagedScript, mHcSymbolTable, SmtUtils.or(getScript(), constraints),
				List.of(mPredicate), List.of(bodyArgs), Set.copyOf(mDefaultHeadVars));
	}

	public HornClause getNonInterferenceClause(final IIcfgTransition<?> edge) {
		final String procedure = edge.getPrecedingProcedure();
		final int n = mNumberOfThreads.get(procedure);
		final List<List<Term>> bodyArguments = new ArrayList<>();
		for (int i = 0; i <= n; i++) {
			bodyArguments.add(getDefaultArgs());
		}
		final TransFormula transformula = edge.getTransformula();
		final Map<TermVariable, Term> substitution = new HashMap<>();
		final Set<HcVar> bodyVars = new HashSet<>();
		final var constraints = new ArrayList<Term>();
		for (final var entry : mPositions2Vars.entrySet()) {
			final int index = entry.getKey();
			final IHcReplacementVar rv = entry.getValue();
			if (rv instanceof HcLocalVar) {
				final HcLocalVar lv = (HcLocalVar) rv;
				if (lv.getProcedure().equals(procedure)) {
					final IProgramVar pv = lv.getVariable();
					final TermVariable inVar = transformula.getInVars().get(pv);
					final TermVariable outVar = transformula.getOutVars().get(pv);
					if (inVar != null) {
						final HcBodyVar bodyVar = mHcSymbolTable.getOrConstructBodyVar(mPredicate, index, pv);
						bodyVars.add(bodyVar);
						final Term bodyVarTerm = bodyVar.getTerm();
						substitution.put(inVar, bodyVarTerm);
						for (int i = 0; i < n; i++) {
							final int newIndex = mPositions2Vars.inverse().get(new HcLocalVar(pv, i));
							bodyArguments.get(i + 1).set(newIndex, bodyVarTerm);
						}
					}
					if (outVar != null && !outVar.equals(inVar)) {
						// TODO: Should this be a HcBodyAuxVar instead? => ChcToBoogie crashes then...
						final HcBodyVar auxVar = mHcSymbolTable.getOrConstructBodyVar(mPredicate, index, pv);
						substitution.put(outVar, auxVar.getTerm());
						bodyVars.add(auxVar);
					}
				}
			} else if (rv instanceof HcGlobalVar) {
				final IProgramVar pv = ((HcGlobalVar) rv).getVariable();
				final TermVariable inVar = transformula.getInVars().get(pv);
				final TermVariable outVar = transformula.getOutVars().get(pv);
				substitution.put(outVar, mDefaultHeadVars.get(index).getTerm());
				if (!Objects.equals(inVar, outVar)) {
					final HcBodyVar bv = mHcSymbolTable.getOrConstructBodyVar(mPredicate, index, pv);
					final Term term = bv.getTerm();
					for (int i = 0; i <= n; i++) {
						bodyArguments.get(i).set(index, term);
					}
					substitution.put(inVar, term);
					bodyVars.add(bv);
				}
			} else if (rv instanceof HcLocationVar) {
				final HcLocationVar lv = (HcLocationVar) rv;
				if (lv.getProcedure().equals(procedure)) {
					final Term loc = getLocIndexTerm(edge.getSource(), procedure);
					for (int i = 0; i < n; i++) {
						final int newIndex =
								mPositions2Vars.inverse().get(new HcLocationVar(procedure, i, getIntSort()));
						bodyArguments.get(i + 1).set(newIndex, loc);
					}
				}
			} else if (rv instanceof HcSleepVar) {
				final var sv = (HcSleepVar) rv;
				final var oldSleep = mHcSymbolTable.getOrConstructBodyVar(mPredicate, index, sv.getSort(), sv);
				bodyVars.add(oldSleep);

				// insert the variable in each body clause (in one, it may be replaced below by the interfering thread)
				for (int i = 0; i <= n; ++i) {
					bodyArguments.get(i).set(index, oldSleep.getTerm());
				}

				final var newSleep = mDefaultHeadVars.get(index);

				final var hcLoc = new HcLocationVar(sv.getThreadTemplateName(), sv.getInstanceIndex(), getIntSort());
				final int locIndex = mPositions2Vars.inverse().get(hcLoc);
				final var locVar = mDefaultHeadVars.get(locIndex);

				final var currentId = mHcSymbolTable.getOrConstructBodyVar(mPredicate, -1, getIntSort(),
						new HcThreadIdVar(getScript(), procedure, -1));
				bodyVars.add(currentId);
				final var otherId = mDefaultHeadVars.get(mPositions2Vars.inverse()
						.get(new HcThreadIdVar(getScript(), sv.getThreadTemplateName(), sv.getInstanceIndex())));

				// update sleep variable depending on commutativity and thread ID ordering
				final Term nonCommConstr = getNonCommutativityConstraint(sv, locVar.getTerm(), edge);
				constraints.add(SmtUtils.binaryBooleanEquality(getScript(),
						SmtUtils.binaryEquality(getScript(), newSleep.getTerm(), numeral(0)),
						SmtUtils.or(getScript(),
								SmtUtils.and(getScript(),
										SmtUtils.greater(getScript(), otherId.getTerm(), currentId.getTerm()),
										SmtUtils.binaryEquality(getScript(), oldSleep.getTerm(), numeral(0))),
								nonCommConstr)));

				// special case: add the constraint that the interfering thread does not sleep
				if (sv.getThreadTemplateName().equals(procedure)) {
					final var bodyVar = mHcSymbolTable.getOrConstructBodyVar(mPredicate, -1, sv.getSort(), sv);
					bodyVars.add(bodyVar);

					// for each non-interference premise, insert the variable in the index for the interfering thread
					for (int i = 0; i < n; ++i) {
						final int newIndex = mPositions2Vars.inverse()
								.get(new HcSleepVar(getScript(), sv.getThreadTemplateName(), i));
						bodyArguments.get(i + 1).set(newIndex, bodyVar.getTerm());
					}

					// add constraint ensuring that the interfering thread is not sleeping
					constraints.add(SmtUtils.binaryEquality(getScript(), bodyVar.getTerm(), numeral(0)));
				}
				continue;
			} else if (rv instanceof HcThreadIdVar) {
				final var iv = (HcThreadIdVar) rv;
				if (iv.getThreadTemplateName().equals(procedure)) {
					final var id = mHcSymbolTable.getOrConstructBodyVar(mPredicate, -1, getIntSort(),
							new HcThreadIdVar(getScript(), procedure, -1));
					bodyVars.add(id);
					for (int i = 0; i < n; ++i) {
						final var newIndex = mPositions2Vars.inverse()
								.get(new HcSleepVar(getScript(), iv.getThreadTemplateName(), i));
						bodyArguments.get(i + 1).set(newIndex, id.getTerm());
					}
				}
			} else {
				throw new UnsupportedOperationException("Unknown kind of variable: " + rv);
			}
		}

		// add ID constraints
		final var instances = mNumberOfThreads.entrySet().stream()
				.flatMap(e -> IntStream.range(0, e.getValue()).mapToObj(i -> new Pair<>(e.getKey(), i)))
				.collect(Collectors.toList());
		final var interferingId = mHcSymbolTable.getOrConstructBodyVar(mPredicate, -1, getIntSort(),
				new HcThreadIdVar(getScript(), procedure, -1));
		assert bodyVars.contains(interferingId);
		for (int i = 0; i < instances.size(); ++i) {
			final var first = instances.get(i);
			final var firstIndex =
					mPositions2Vars.inverse().get(new HcThreadIdVar(getScript(), first.getKey(), first.getValue()));
			final var firstId = mDefaultHeadVars.get(firstIndex);

			for (int j = i + 1; j < instances.size(); ++j) {
				final var second = instances.get(j);
				final var secondIndex = mPositions2Vars.inverse()
						.get(new HcThreadIdVar(getScript(), second.getKey(), second.getValue()));
				final var secondId = mDefaultHeadVars.get(secondIndex);

				constraints.add(SmtUtils.less(getScript(), firstId.getTerm(), secondId.getTerm()));
			}

			constraints.add(SmtUtils.distinct(getScript(), interferingId.getTerm(), firstId.getTerm()));
		}

		// Replace all other variables with aux-vars
		final Term formula = transformula.getFormula();
		for (final TermVariable v : formula.getFreeVars()) {
			if (substitution.containsKey(v)) {
				continue;
			}
			// TODO: Using the number of bodyVars as index is a hack!
			final HcBodyVar auxVar = mHcSymbolTable.getOrConstructBodyVar(mPredicate, bodyVars.size(), v.getSort(), v);
			substitution.put(v, auxVar.getTerm());
			bodyVars.add(auxVar);
		}
		constraints.add(Substitution.apply(mManagedScript, substitution, transformula.getFormula()));
		return constructHornClause(SmtUtils.and(getScript(), constraints), bodyArguments, bodyVars);
	}

	public interface IHcReplacementVar {
		Sort getSort();
	}
}
