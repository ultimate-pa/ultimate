/*
 * Copyright (C) 2009-2012 University of Freiburg
 *
 * This file is part of SMTInterpol.
 *
 * SMTInterpol is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SMTInterpol is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SMTInterpol.  If not, see <http://www.gnu.org/licenses/>.
 */
/* CUP specification for smtlib */

package de.uni_freiburg.informatik.ultimate.smtinterpol.smtlib2;
import de.uni_freiburg.informatik.ultimate.logic.*;
import de.uni_freiburg.informatik.ultimate.util.datastructures.ScopedHashMap;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.util.Arrays;
import com.github.jhoenicke.javacup.runtime.Symbol;
import com.github.jhoenicke.javacup.runtime.SimpleSymbolFactory;
import java.util.Map;

parser Parser;
option symbols = LexerSymbols;
option java15, compact_red, newpositions;

parser code {:
	String filename;
	ParseEnvironment env;

	public static final Sort[] EMPTY_SORT_ARRAY = {};

	public void report_error(String s, Object sym) {
		String location;
		if (sym instanceof SimpleSymbolFactory.LineColumnSymbol) {
			SimpleSymbolFactory.LineColumnSymbol bsym = (SimpleSymbolFactory.LineColumnSymbol) sym;
			location = bsym.getLocation();
		} else if ((sym instanceof Symbol)
				   && ((Symbol)sym).sym == LexerSymbols.EOF) {
			location = "EOF";
		} else
			location = "UNKNOWN";

		action_obj.setError(filename+":"+location+": "+s);
	}

	public void report_error(String s) {
		report_error(s, cur_token);
	}

	public void syntax_error(Symbol sym) {
		report_error("Syntax Error", sym);
		env.printError(action_obj.getError());
	}

	public void setFileName(String filename) {
		this.filename = filename;
	}

	public void setParseEnvironment(ParseEnvironment env) {
		this.env = env;
	}
:}

action code {:
	ScopedHashMap<String,TermVariable> localVars =
		new ScopedHashMap<String, TermVariable>(false);
	Sort[] mSortParams = null;
	static Sort[] emptySortArray = new Sort[0];
	Sort mMatchSort = null;

	static class Binding {
		TermVariable mVar;
		Term mTerm;
		public Binding(TermVariable var, Term term) {
			mVar = var;
			mTerm = term;
		}
		TermVariable getVar() {
			return mVar;
		}
		Term getTerm() {
			return mTerm;
		}
	}

	static class IndexedIdentifier {
		String mName;
		String[] mIndices;
		public IndexedIdentifier(String name, String[] indices) {
			mName = name;
			mIndices = indices;
		}
		public String getName() {
			return mName;
		}
		public String[] getIndices() {
			return mIndices;
		}

		public String toString() {
			if (mIndices == null)
				return mName;
			return "(_ "+mName+" "+Arrays.toString(mIndices)+")";
		}
	}

	static class QualIdentifier {
		String mName;
		String[] mIndices;
		Sort mSort;
		public QualIdentifier(IndexedIdentifier id, Sort sort) {
			mName = id.getName();
			mIndices = id.getIndices();
			mSort = sort;
		}
		public String getIdentifier() {
			return mName;
		}
		public String[] getIndices() {
			return mIndices;
		}
		public Sort getSort() {
			return mSort;
		}

		public String toString() {
			String indexedId;
			if (mIndices == null)
				indexedId = mName;
			else
				indexedId = "(_ "+mName+" "+Arrays.toString(mIndices)+")";
			if (mSort == null)
				return indexedId;
			return "(as " + indexedId + " " + mSort + ")";
		}
	}

	static class SelectorDec {
		String mSelector;
		Sort mArgumentSort;
		public SelectorDec(String selector, Sort argumentSort) {
			mSelector = selector;
			mArgumentSort = argumentSort; 
		}
		public String getSelector() {
			return mSelector;
		}
		public Sort getArgumentSort() {
			return mArgumentSort;
		}
		public String toString() {
			return "(" + mSelector + " " + mArgumentSort + ")";
		}
	}

	static class ParametricConstructors {
		final DataType.Constructor[] mConstructors;
		final Sort[] mSortParams;
		public ParametricConstructors(DataType.Constructor[] constructors) {
			mConstructors = constructors;
			mSortParams = null;
		}
		public ParametricConstructors(DataType.Constructor[] constructors, Sort[] sortparams) {
			mConstructors = constructors;
			mSortParams = sortparams;
		}
		public DataType.Constructor[] getConstructors() {
			return mConstructors;
		}
		public Sort[] getSortParams() {
			return mSortParams;
		}
	}

	class Pattern {
		DataType.Constructor mConstructor;
		TermVariable[] mVars;
		Sort[] mSorts;

		public Pattern(String constructor, String[] vars) {
			for (int i = 0; i < vars.length; i++) {
				for (int j = 0; j < i; j++) {
					if (vars[j].equals(vars[i])) {
						throw new SMTLIBException("Variables must all be distinct.");
					}
				}
			}

			DataType dataType = (DataType) mMatchSort.getSortSymbol();
			mConstructor = dataType.findConstructor(constructor);
			if (mConstructor == null) {
				throw new SMTLIBException("Constructor not found.");
			}
			mSorts = mConstructor.getArgumentSorts();
			mVars = new TermVariable[vars.length];
			if (mSorts.length != mVars.length) {
				throw new SMTLIBException("Number of constructor arguments does not match.");
			}

			for (int i = 0; i < vars.length; i++) {
				Sort sort = mSorts[i].mapSort(mMatchSort.getArguments());
				mVars[i] = createTermVariable(vars[i], sort);
			}
		}

		public Pattern(String constructor) {
			mConstructor = ((DataType) mMatchSort.getSortSymbol()).findConstructor(constructor);
			if (mConstructor == null) {
				mVars = new TermVariable[1];
				mVars[0] = createTermVariable(constructor, mMatchSort);
			} else {
				mVars = new TermVariable[0];
				if (mConstructor.getArgumentSorts().length != 0) {
					throw new SMTLIBException("Number of constructor arguments does not match.");
				}
			}
		}

		public TermVariable[] getVars() {
			return mVars;
		}

		public DataType.Constructor getConstructor() {
			return mConstructor;
		}

		public String toString() {
			if (mConstructor == null) {
				return mVars[0].toString();
			} else {
				StringBuilder sb = new StringBuilder();
				sb.append('('). append(mConstructor.getName());
				for (TermVariable tv : mVars) {
					sb.append(' ').append(tv);
				}
				sb.append(')');
				return sb.toString();
			}
		}
	}

	static class MatchCase {
		Pattern mPattern;
		Term mCase;

		public MatchCase(Pattern pattern, Term caseTerm) {
			mPattern = pattern;
			mCase = caseTerm;
		}

		public Pattern getPattern() {
			return mPattern;
		}

		public Term getCase() {
			return mCase;
		}

		public String toString() {
			return "(" + mPattern + " " + mCase + ")";
		}
	}

	Term createMatchTerm (Symbol sym, Term dataArg, MatchCase[] matchCases) {
		/* first check if some argument is null.  In this case we already reported an error and should return null. */
		if (mMatchSort == null) {
			return null;
		}
		for (MatchCase matchCase : matchCases) {
			if (matchCase == null) {
				return null;
			}
		}
		DataType matchDatatype = (DataType) mMatchSort.getSortSymbol();
		if (!checkPatterns(matchDatatype, matchCases)) {
			parser.report_error("Either match term contains a pattern consisting of a variable or all constructors must occur in one of the patterns.", sym);
			return null;
		}
		TermVariable[][] vars = new TermVariable[matchCases.length][];
		Term[] cases = new Term[matchCases.length];
		DataType.Constructor[] constructors = new DataType.Constructor[matchCases.length];
		for (int i = 0; i < matchCases.length; i++) {
			vars[i] = matchCases[i].getPattern().getVars();
			cases[i] = matchCases[i].getCase();
			constructors[i] = matchCases[i].getPattern().getConstructor();
		}
		return parser.env.getScript().match(dataArg, vars, cases, constructors);
	}

	// Function to check that either match term contains a pattern consisting of a variable
	// or all constructors must occur in one of the patterns.
	public boolean checkPatterns(DataType matchDatatype, MatchCase[] matchCases) {
		for (int i = 0; i < matchCases.length; i++) {
			if (matchCases[i].getPattern().getConstructor() == null) {
				return true;
			}
		}
		DataType.Constructor[] allConstrs = matchDatatype.getConstructors();
		for (int i = 0; i < allConstrs.length; i++) {
			boolean constrFound = false;
			for (int j = 0; j < matchCases.length; j++) {
				if (matchCases[j].getPattern().getConstructor().getName().equals(allConstrs[i].getName())) {
					constrFound = true;
				}
			}
			if (!constrFound) {
				return false;
			}
		}
		return true;
	}

	String errorMessage;
	public void setError(String message) {
		if (errorMessage == null)
			errorMessage = message;
	}
	public boolean hasError() {
		return errorMessage != null;
	}
	public String getError() {
		String result = errorMessage;
		errorMessage = null;
		return result;
	}

	private Sort[] getSortParams() {
		return mSortParams;
	}

	private void pushSortParams(String[] sortVars) {
		assert mSortParams == null;
		mSortParams = parser.env.getScript().sortVariables(sortVars);
	}

	private void popSortParams() {
		assert mSortParams != null;
		mSortParams = null;
	}

	public Sort lookupSort(Symbol sym, IndexedIdentifier id, Sort[] args) {
		for (Sort s: args) {
			if (s == null) return null;
		}
		String name = id.getName();
		if (args.length == 0 && id.getIndices() == null && mSortParams != null) {
			for (Sort s: mSortParams) {
				if (s.getName().equals(name))
					return s;
			}
		}
		try {
			return parser.env.getScript().sort(name, id.getIndices(), args);
		} catch (SMTLIBException se) {
			parser.report_error("Undeclared sort ("+id+" "+args.length+")", sym);
		}
		return null;
	}

	public Term createTerm(Symbol fsym, String name, String[] indices, Sort resultSort, Term[] param) {
		// check if there was an error when creating the child term.
		for (Term p : param) {
			if (p == null)
				return null;
		}
		try {
			return parser.env.getScript().term(name, indices, resultSort, param);
		} catch (SMTLIBException se) {
			parser.report_error(se.getMessage(), fsym);
		}
		return null;
	}

	public TermVariable createTermVariable(String name, Sort sort) {
		if (sort == null)
			return null;
		try {
			TermVariable tv = parser.env.getScript().variable(name, sort);
			localVars.put(tv.getName(), tv);
			return tv;
		} catch (SMTLIBException cannotHappen) {}
		// Actually unreachable
		throw new AssertionError();
	}

	private Term getTermVariable(String name) {
		return localVars.get(name);
	}

	public Term annotateTerm(Term term, Annotation[] annots) {
		if (term == null)
			return null;
		try {
			return parser.env.getScript().annotate(term, annots);
		} catch (SMTLIBException se) {
			parser.report_error(se.getMessage());
		}
		return null;
	}
:}

/*init with {: getScanner().init(); :} */
scan with {: return getScanner().next_token(); :}


/* Predefined Symbols */
terminal String UNDERSCORE, BANG,
         AS, ASSERT, CHECKSAT, CONTINUEDEXECUTION,
         DECLARESORT, DECLAREFUN, DECLARECONST, DECLAREDATATYPE, DECLAREDATATYPES,
         DEFINESORT, DEFINEFUN, ERRORSYM,
         EXISTS, EXIT, FALSE, FORALL, GETASSERTIONS, GETASSIGNMENT, GETINFO,
         GETINTERPOLANTS,
         GETMODEL, GETOPTION, GETPROOF, GETUNSATCORE, GETVALUE, IMMEDIATEEXIT,
         INCOMPLETE, LET, LOGIC, NONE, NUMERALSYM, MATCH, MEMOUT, PAR, POP, PUSH,
         DECIMALSYM, SAT, SUCCESS, SETLOGIC, SETINFO, SETOPTION, STRINGSYM,
         THEORY, TRUE, UNKNOWN, UNSUPPORTED, UNSAT,
         INCLUDE, RESET, RESETASSERTIONS, SIMPLIFY, TIMED, ALLSAT, ECHO,
         FINDIMPLIEDEQUALITY, CHECKSATASSUMING, GETUNSATASSUMPTIONS;

/* Predefined Keywords */
terminal String /* attribute */
         CNAMED, CPATTERN,
         /* theory */
         CSORTSDESCRIPTION, CSORTS, CFUNS, CFUNSDESCRIPTION, CDEFINITION,
         /* logic */
         CEXTENSIONS, CLANGUAGE, CTHEORIES,
         /* theory + logic */
         CNOTES, CVALUES,
         /* options */
         CDIAGNOSTICOUTPUTCHANNEL, CREGULAROUTPUTCHANNEL,
         CEXPANDDEFINITIONS, CINTERACTIVEMODE, CPRINTSUCCESS, CVERBOSITY,
         CPRODUCEASSIGNMENTS, CPRODUCEMODELS, CPRODUCEPROOFS, CPRODUCEUNSATCORES,
         CRANDOMSEED, CINTERPOLANTCHECKMODE, CSTRONGSIMPLIFIER,
         CTIMEOUT, CPRODUCEUNSATASSUMPTIONS;
terminal String SYMBOL, KEYWORD;
terminal BigInteger NUMERAL;
terminal BigDecimal DECIMAL;
terminal String HEXADECIMAL, BINARY, STRING;
terminal LPAR, RPAR;

non terminal String keyword, symbol, allsymbol;
non terminal String keywordAttr, keywordOption;
non terminal String keywordTheory, keywordLogic, keywordTheoryLogic;
non terminal String keywordNoAttr, keywordNoTheory, keywordNoLogic, keywordNoOption;
non terminal String booleanOption, stringOption, numeralOption;
non terminal String index;
non terminal IndexedIdentifier identifier, identifierIndexed;
non terminal Object specConstant;
non terminal Object sExpr;
non terminal QuotedObject string;

non terminal Sort sort;
non terminal Object attributeValue;
non terminal Annotation attribute;
non terminal Annotation attributeTheory, attributeLogic;
non terminal QualIdentifier qualIdentifier;
non terminal Binding varBinding;
non terminal TermVariable sortedVar;
non terminal Pattern pattern;
non terminal MatchCase matchCase;
non terminal Term constantTerm, term;
non terminal InterpolationInfo interpolantpartition;
non terminal SelectorDec selectorDec;
non terminal DataType sortDec, sortDec0;
non terminal DataType.Constructor constructorDec;
non terminal ParametricConstructors datatypeDec;
non terminal sortSymbolDecl;
non terminal metaSpecConstant;
non terminal parFunSymbolDecl, funSymbolDecl;
non terminal theoryAttribute;
non terminal logicAttribute;
non terminal Boolean bValue;
non terminal Object[] option;
non terminal String infoFlag;
non terminal command;
non terminal commandPar;
non terminal goal, theoryDecl, logic, script;

goal ::= theoryDecl | logic | script;

string ::= STRING:n {: RESULT = new QuotedObject(n, parser.env.isSMTLIB25()); :};

specConstant ::= NUMERAL
             | DECIMAL
             | HEXADECIMAL
             | BINARY
             | string;
sExpr ::= specConstant
        | allsymbol
        | KEYWORD
        | LPAR sExpr*:s RPAR {: RESULT = s; :};

constantTerm ::= NUMERAL:n
				{: try {
					RESULT = parser.env.getScript().numeral(n);
					} catch (SMTLIBException se) {
						parser.report_error(se.getMessage());
						RESULT = null;
					} :}
             | DECIMAL:n
             	{: try {
             		RESULT = parser.env.getScript().decimal(n);
             		} catch (SMTLIBException se) {
             			parser.report_error(se.getMessage());
             			RESULT = null;
             		} :}
             | HEXADECIMAL:n {: try {
             		RESULT = parser.env.getScript().hexadecimal(n);
             		} catch (SMTLIBException se) {
             			parser.report_error(se.getMessage());
             			RESULT = null;
             		}  :}
             | BINARY:n {: try {
             		RESULT = parser.env.getScript().binary(n);
             		} catch (SMTLIBException se) {
             			parser.report_error(se.getMessage());
             			RESULT = null;
             		} :}
             | string:n {: try {
                    RESULT = parser.env.getScript().string(n);
             		} catch (SMTLIBException se) {
             			parser.report_error(se.getMessage());
             			RESULT = null;
             		} :};
index ::= NUMERAL:n {: RESULT = n.toString(); :} | symbol | HEXADECIMAL | BINARY;
identifierIndexed ::= LPAR UNDERSCORE symbol:id index+:indices RPAR
             {: RESULT = new IndexedIdentifier(id, indices); :};
identifier ::= symbol:s {: RESULT = new IndexedIdentifier(s, null); :}
           | identifierIndexed;

sort ::= identifier:id {: RESULT = lookupSort(id$, id, emptySortArray); :}
       | LPAR identifier:id sort+:sorts RPAR
         {: RESULT = lookupSort(id$, id, sorts); :};
attribute ::= keywordNoAttr:k attributeValue?:v {: RESULT = new Annotation(k, v); :}
        | CNAMED:k symbol:v {: RESULT = new Annotation(k, v); :}
        | CPATTERN:k LPAR term*:t RPAR {: RESULT = new Annotation(k, t); :};
attributeValue ::= specConstant
        | symbol
        | LPAR sExpr*:s RPAR {: RESULT = s; :};
attributeLogic  ::= keywordNoLogic:k  attributeValue?:v
                    {: RESULT = new Annotation(k, v); :};
attributeTheory ::= keywordNoTheory:k attributeValue?:v
                    {: RESULT = new Annotation(k, v); :};

qualIdentifier ::= identifier:i
         {: RESULT = new QualIdentifier(i, null); :}
       | LPAR AS identifier:i sort:s RPAR
         {: RESULT = new QualIdentifier(i, s); :};
varBinding ::= LPAR symbol:sym term:t RPAR
         {: if (hasError()) {
            	RESULT = null;
            } else {
         		TermVariable tv = createTermVariable(sym, t.getSort());
            	RESULT = new Binding(tv, t);
            }
          :};
sortedVar ::= LPAR symbol:sym sort:s RPAR
         {: RESULT = createTermVariable(sym, s); :};
pattern ::= symbol:sym
         {: if (mMatchSort == null) {
            	RESULT = null;
            } else {
            	try {
            		RESULT = new Pattern(sym);
            	} catch (SMTLIBException ex) {
            		parser.report_error(ex.getMessage(), sym$);
            		RESULT = null;
            	}
            }
         :}
       | LPAR symbol:constr symbol+:vars RPAR
         {: if (mMatchSort == null) {
            	RESULT = null;
            } else {
            	try {
            		RESULT = new Pattern(constr, vars);
            	} catch (SMTLIBException ex) {
            		parser.report_error(ex.getMessage(), constr$);
            		RESULT = null;
            	}
            }
         :};
matchCase ::= LPAR {: localVars.beginScope(); :} pattern:p term:t RPAR
         {:
            localVars.endScope();
            if (p != null && t != null) {
            	RESULT = new MatchCase(p, t);
            }
         :};
term ::= constantTerm
       | qualIdentifier:fun
         {: RESULT = fun.getIndices() == null && fun.getSort() == null ? getTermVariable(fun.getIdentifier()) : null;
            if (RESULT == null)
                RESULT = createTerm(fun$, fun.getIdentifier(), fun.getIndices(), fun.getSort(), new Term[0]); :}
       | LPAR qualIdentifier:fun term+:args RPAR
         {: RESULT = createTerm(fun$, fun.getIdentifier(), fun.getIndices(), fun.getSort(), args); :}
       | LPAR LET {: localVars.beginScope(); :}
                  LPAR varBinding+:bindings RPAR term:t RPAR
         {: TermVariable[] vars = new TermVariable[bindings.length];
            Term[] terms = new Term[bindings.length];
            for (int i = 0; i < bindings.length; i++) {
            	if (bindings[i] != null) {
               		vars[i] = bindings[i].getVar();
               		terms[i] = bindings[i].getTerm();
               	}
            }
            localVars.endScope();
            if (hasError())
            	RESULT = null;
            else
            	RESULT = parser.env.getScript().let(vars, terms, t); :}
       | LPAR FORALL:sym {: localVars.beginScope(); :}
              LPAR sortedVar+:vars RPAR term:t RPAR
         {: localVars.endScope();
           	RESULT = null;
			try {
            	if (!hasError())
            		RESULT = parser.env.getScript().quantifier(Script.FORALL, vars, t);
			} catch (SMTLIBException se) {
				parser.report_error(se.getMessage(), sym$);
			} :}
       | LPAR EXISTS:sym {: localVars.beginScope(); :}
              LPAR sortedVar+:vars RPAR term:t RPAR
         {: localVars.endScope();
           	RESULT = null;
			try {
            	if (!hasError()) {
            		RESULT = parser.env.getScript().quantifier(Script.EXISTS, vars, t);
            	}
			} catch (SMTLIBException se) {
				parser.report_error(se.getMessage(), sym$);
			} :}
       | LPAR MATCH:sym 
            term:dataArg
         {:
            if (dataArg != null) {
            	mMatchSort = dataArg.getSort();
            	if (!mMatchSort.getSortSymbol().isDatatype()) {
            		parser.report_error("Match term must be of a datatype sort.", sym$);
            		mMatchSort = null;
            	}
            } :}
            LPAR matchCase+:matchCases RPAR RPAR
         {:
            RESULT = createMatchTerm(sym$, dataArg, matchCases);
            mMatchSort = null;
         :}
       | LPAR BANG term:t attribute+:attr RPAR
         {: RESULT = annotateTerm(t, attr); :};

sortSymbolDecl ::= LPAR identifier NUMERAL attribute* RPAR;
metaSpecConstant ::= NUMERALSYM | DECIMALSYM | STRINGSYM;
funSymbolDecl ::= LPAR specConstant sort attribute* RPAR
                | LPAR metaSpecConstant sort attribute* RPAR
                | LPAR identifier sort+ attribute* RPAR;

parFunSymbolDecl ::= funSymbolDecl
       | LPAR PAR LPAR symbol+ RPAR
                  LPAR identifier sort+ attribute* RPAR RPAR;
theoryAttribute ::= CSORTS LPAR sortSymbolDecl+ RPAR
                  | CFUNS  LPAR parFunSymbolDecl+ RPAR
                  | CSORTSDESCRIPTION STRING
                  | CFUNSDESCRIPTION STRING
                  | CDEFINITION STRING
                  | CVALUES STRING
                  | CNOTES STRING
                  | attributeTheory;
theoryDecl ::= LPAR THEORY symbol theoryAttribute+ RPAR;

logicAttribute ::= CTHEORIES LPAR symbol+ RPAR
                 | CLANGUAGE STRING
                 | CEXTENSIONS STRING
                 | CVALUES STRING
                 | CNOTES STRING
                 | attributeLogic;
logic ::= LPAR LOGIC symbol logicAttribute+ RPAR;

bValue ::= TRUE {: RESULT = true; :} | FALSE {: RESULT = false; :};

booleanOption ::= CPRINTSUCCESS | CEXPANDDEFINITIONS | CINTERACTIVEMODE
                | CPRODUCEPROOFS | CPRODUCEUNSATCORES | CPRODUCEMODELS
                | CPRODUCEASSIGNMENTS | CINTERPOLANTCHECKMODE
                | CSTRONGSIMPLIFIER | CPRODUCEUNSATASSUMPTIONS;
stringOption ::= CREGULAROUTPUTCHANNEL | CDIAGNOSTICOUTPUTCHANNEL;
numeralOption ::= CRANDOMSEED | CVERBOSITY | CTIMEOUT;
option ::= booleanOption:o bValue:b {: RESULT = new Object[] { o, b }; :}
         | stringOption:o STRING:s {: RESULT = new Object[] { o, s }; :}
         | numeralOption:o NUMERAL:n {: RESULT = new Object[] { o, n }; :}
         | keywordNoOption:o attributeValue?:v {: RESULT = new Object[] { o, v }; :}
         ;
infoFlag ::= keyword;

interpolantpartition
         ::= interpolantpartition:child SYMBOL:symb
             {: if (child.isEmpty() && symb.equals("and"))
                   child.makeAndTerm();
                else
                   child.addParent(createTerm(symb$, symb, null, null, new Term[0]));
                 RESULT = child;:}
           | interpolantpartition:child LPAR interpolantpartition:sibling RPAR
             {: if (sibling.isAndTerm() && !hasError()) {
             	    child.addParent(parser.env.getScript()
             	    				.term("and", sibling.getPartition()));
                } else if (child.isClosedTree()) {
				    child.addSibling(sibling);
				} else {
					parser.report_error("Interpolation tree malformed.", child$);
				}
                RESULT = child; :}
           | /* empty */
             {: RESULT = new InterpolationInfo(); :}
           ;

sortDec ::= LPAR symbol:type NUMERAL:numParams RPAR
            {: RESULT = parser.env.getScript().datatype(type, numParams.intValueExact()); :}
            ;

/* sort declaration in declare-datatype is always of arity 0 */
sortDec0 ::= symbol:type
            {: RESULT = parser.env.getScript().datatype(type, 0); :}
            ;

selectorDec ::= LPAR symbol:selector sort:argumentSort RPAR
              {:
              RESULT = new SelectorDec(selector, argumentSort);
              :};


constructorDec ::= LPAR symbol:name selectorDec*:selDec RPAR
                   {:    
                   String[] selectors = new String[selDec.length];
                   Sort[] argumentSorts = new Sort[selDec.length];
                   
                   for (int i = 0; i < selDec.length; i++) {

                       selectors[i] = selDec[i].getSelector();
                       argumentSorts[i] = selDec[i].getArgumentSort();
                       
                       
                   }
                   RESULT = parser.env.getScript().constructor(name, selectors, argumentSorts);
                   :};

datatypeDec ::= LPAR constructorDec+:cons RPAR
                {: RESULT = new ParametricConstructors(cons); :} 
              | LPAR PAR LPAR symbol+:sortvars RPAR
                {: pushSortParams(sortvars); :}
                LPAR constructorDec+:cons RPAR RPAR
                {: RESULT = new ParametricConstructors(cons, getSortParams()); popSortParams(); :} 
              ;

command ::= SETLOGIC symbol:logic
            {: try {
                   parser.env.getScript().setLogic(logic);
                   parser.env.printSuccess();
               } catch (UnsupportedOperationException uoe) {
                   parser.env.printUnsupported();
               } catch (SMTLIBException se) {
                   parser.report_error(se.getMessage(), logic$);
                   parser.env.printError(getError());
               }
             :}
          | SETOPTION option:opt
            {: try {
                   parser.env.getScript().setOption((String) opt[0], opt[1]);
                   parser.env.printSuccess();
               } catch (UnsupportedOperationException uoe) {
                   parser.env.printUnsupported();
               } catch (SMTLIBException se) {
                   parser.report_error(se.getMessage(), opt$);
                   parser.env.printError(getError());
               }
            :}
          | SETINFO keyword:k attributeValue?:v
            {: try {
                   parser.env.setInfo(k, v);
                   parser.env.printSuccess();
               } catch (UnsupportedOperationException uoe) {
                   parser.env.printUnsupported();
               } catch (SMTLIBException se) {
                   parser.report_error(se.getMessage(), k$);
                   parser.env.printError(getError());
               }
            :}
          | DECLARESORT symbol:sort NUMERAL:n
            {:
                if (n.bitLength() >= 32)
                    parser.report_error("sort has too many arguments", n$);
                if (hasError()) {
                    parser.env.printError(getError());
                } else {
                    try {
                        parser.env.getScript().declareSort(sort, n.intValue());
                        parser.env.printSuccess();
                    } catch (SMTLIBException se) {
                        parser.report_error(se.getMessage(), sort$);
                        parser.env.printError(getError());
                    }
                }
            :}
          | DEFINESORT symbol:sort LPAR symbol*:sortVars
            {: pushSortParams(sortVars); :}
            RPAR sort:def
            {: if (hasError()) {
                   parser.env.printError(getError());
               } else {
                   try {
                       parser.env.getScript().defineSort(sort, getSortParams(), def);
                       parser.env.printSuccess();
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage(), sort$);
                       parser.env.printError(getError());
                   }
               }
               popSortParams();
            :}
          | DECLAREFUN symbol:fun LPAR sort*:param RPAR sort:result
            {: if (hasError()) {
                   parser.env.printError(getError());
               } else {
                   try {
                       parser.env.getScript().declareFun(fun, param, result);
                       parser.env.printSuccess();
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage(), fun$);
                       parser.env.printError(getError());
                   }
               }
            :}
          | DECLARECONST symbol:fun sort:result
            {:  if (hasError())
                    parser.env.printError(getError());
                else {
                    try {
                        parser.env.getScript().declareFun(fun, Script.EMPTY_SORT_ARRAY, result);
                        parser.env.printSuccess();
                    } catch(SMTLIBException se) {
                        parser.report_error(se.getMessage(), fun$);
                        parser.env.printError(getError());
                    }
               }
            :}
          | DECLAREDATATYPE sortDec0:datatype datatypeDec:dataDec
            {:
              try {
                  parser.env.getScript().declareDatatype(datatype, dataDec.getConstructors());
                  parser.env.printSuccess();
              } catch (SMTLIBException se) {
                  parser.report_error(se.getMessage(), datatype$);
                  parser.env.printError(getError());
              }
            :}
          | DECLAREDATATYPES LPAR sortDec+:datatypes RPAR LPAR datatypeDec+:dataDecs RPAR
            {:
              DataType.Constructor[][] constructors = new DataType.Constructor[dataDecs.length][];
              Sort[][] sortParams = new Sort[dataDecs.length][];
              for (int i = 0; i < dataDecs.length; i++) {
                  constructors[i] = dataDecs[i].getConstructors();
                  sortParams[i] = dataDecs[i].getSortParams();
              }
              try {
                  parser.env.getScript().declareDatatypes(datatypes, constructors, sortParams);
                  parser.env.printSuccess();
              } catch (SMTLIBException se) {
                  parser.report_error(se.getMessage(), datatypes$);
                  parser.env.printError(getError());
              }
            :}
          | DEFINEFUN {: localVars.beginScope(); :} symbol:fun
                      LPAR sortedVar*:param RPAR sort:resultSort term:value
            {: localVars.endScope();
               if (hasError())
                   parser.env.printError(getError());
               else {
                   try {
                       parser.env.getScript().defineFun(fun, param, resultSort, value);
                       parser.env.printSuccess();
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage(), fun$);
                       parser.env.printError(getError());
                   }
               }
            :}
          | PUSH NUMERAL:n
            {: if (n.bitLength() >= 32)  {
                   parser.report_error("too many push levels", n$);
                   parser.env.printError(getError());
               } else {
               	   try {
                       parser.env.getScript().push(n.intValue());
                       parser.env.printSuccess();
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage(), n$);
                       parser.env.printError(getError());
                   }
               } :}
          | POP NUMERAL:n
            {: if (n.bitLength() >= 32) {
                   parser.report_error("too many pop levels", n$);
                   parser.env.printError(getError());
               } else {
                   try {
                       parser.env.getScript().pop(n.intValue());
                       parser.env.printSuccess();
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage(), n$);
                       parser.env.printError(getError());
                   }
               } :}
          | PUSH
            {: try {
                   parser.env.getScript().push(1);
                   parser.env.printSuccess();
               } catch (SMTLIBException se) {
                   parser.report_error(se.getMessage());
                   parser.env.printError(getError());
               } :}
          | POP
            {: try {
                   parser.env.getScript().pop(1);
                   parser.env.printSuccess();
               } catch (SMTLIBException se) {
                   parser.report_error(se.getMessage());
                   parser.env.printError(getError());
               } :}
          | ASSERT term:t
            {: if (hasError()) {
                   parser.env.printError(getError());
               } else {
                   try {
                       parser.env.getScript().assertTerm(t);
                       parser.env.printSuccess();
                   } catch (UnsupportedOperationException ignored) {
                       parser.env.printUnsupported();
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage());
                       parser.env.printError(getError());
                   }
               }
            :}
          | CHECKSAT
            {: try {
                Script.LBool res = parser.env.getScript().checkSat();
                parser.env.printResponse(res);
            } catch(SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            } catch (UnsupportedOperationException ignored) {
                parser.env.printUnsupported();
            } :}
          | CHECKSATASSUMING LPAR term*:t RPAR
            {:
                if (hasError()) {
                    parser.env.printError(getError());
                } else {
                    try {
                        Script.LBool res = parser.env.getScript().checkSatAssuming(t);
                        parser.env.printResponse(res);
                    } catch (UnsupportedOperationException ignored) {
                        parser.env.printUnsupported();
                    } catch(SMTLIBException se) {
                        parser.report_error(se.getMessage());
                        parser.env.printError(getError());
                    }
                }
            :}
          | GETASSERTIONS
            {: try {
            	parser.env.printResponse(new AssertionList(parser.env.getScript().getAssertions()));
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            } :}
          | GETINTERPOLANTS interpolantpartition:ips
            {: if (!ips.isClosedTree())
                   parser.report_error("Interpolation tree malformed", ips$);
               if (hasError()) {
                  parser.env.printError(getError());
               } else {
                   try {
                       Term[] partition = ips.getPartition();
                       int[] startOfSubtree = ips.getTreeStructure();
                       Term[] res = parser.env.getScript()
                           .getInterpolants(partition, startOfSubtree);
                       parser.env.printResponse(new SExpression(res));
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage());
                       parser.env.printError(getError());
                   } catch (UnsupportedOperationException ignored) {
                       parser.env.printUnsupported();
                   }
               } :}
          | GETPROOF
            {: try {
                Term proof = parser.env.getScript().getProof();
                parser.env.printResponse(proof);
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            } catch (UnsupportedOperationException uoe) {
                parser.env.printUnsupported();
            } :}
          | GETUNSATCORE
            {: try {
                Term[] res = parser.env.getScript().getUnsatCore();
                parser.env.printResponse(new SExpression(res));
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            } catch (UnsupportedOperationException uoe) {
                parser.env.printUnsupported();
            } :}
          | GETUNSATASSUMPTIONS
            {: try {
                Term[] res = parser.env.getScript().getUnsatAssumptions();
                parser.env.printResponse(new SExpression(res));
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            } catch (UnsupportedOperationException uoe) {
                parser.env.printUnsupported();
            } :}
          | GETMODEL
            {: try {
                Model model = parser.env.getScript().getModel();
                parser.env.printResponse(model);
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            } catch (UnsupportedOperationException uoe) {
                parser.env.printUnsupported();
            } :}
          | GETVALUE LPAR term+:t RPAR
            {: if (hasError()) {
                   parser.env.printError(getError());
               } else {
                   try {
                       Map<Term, Term> val = parser.env.getScript().getValue(t);
                       parser.env.printResponse(new GetValueResult(val));
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage());
                       parser.env.printError(getError());
                   }
               } :}
          | GETASSIGNMENT
            {: try {
                Assignments ass = parser.env.getScript().getAssignment();
                parser.env.printResponse(ass);
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            } catch (UnsupportedOperationException uoe) {
                parser.env.printUnsupported();
            } :}
          | GETOPTION keyword:opt
            {: try {
                parser.env.printResponse(parser.env.getScript().getOption(opt));
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            } catch (UnsupportedOperationException uoe) {
                parser.env.printUnsupported();
            } :}
          | GETINFO infoFlag:info
            {: try {
                parser.env.printResponse(new SExpression(new Object[] { info, parser.env.getInfo(info) }));
            } catch (UnsupportedOperationException ignored) {
                parser.env.printUnsupported();
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            } :}
          | INCLUDE STRING:file
            {: try {
                parser.env.include(file);
                parser.env.printSuccess();
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage());
                parser.env.printError(getError());
            }:}
          | SIMPLIFY term:t
            {: if (hasError())
                   parser.env.printError(getError());
               else
                   parser.env.printResponse(parser.env.getScript().simplify(t));
            :}
          | RESET
            {: parser.env.getScript().reset(); parser.env.printSuccess(); :}
          | RESETASSERTIONS
            {: parser.env.getScript().resetAssertions(); parser.env.printSuccess(); :}
          | EXIT
            {: parser.done_parsing(); /* Only exit the parser. */ :}
          | TIMED
            {: parser.env.startTiming(); :}
            commandPar*
            {: parser.env.endTiming(); :}
          | ALLSAT LPAR term+:p RPAR
            {: if (hasError()) {
                   parser.env.printError(getError());
               } else {
                   try {
                       parser.env.printResponse(new SExpression(parser.env.getScript().checkAllsat(p)));
                   } catch (UnsupportedOperationException ignored) {
                       parser.env.printUnsupported();
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage());
                       parser.env.printError(getError());
                   }
               }
            :}
          | ECHO STRING:msg
            {: parser.env.printResponse(parser.env.getScript().echo(new QuotedObject(msg, parser.env.isSMTLIB25()))); :}
          | FINDIMPLIEDEQUALITY LPAR term+:x RPAR LPAR term+:y RPAR
            {: if (hasError()) {
                   parser.env.printError(getError());
               } else {
                   try {
                       parser.env.printResponse(parser.env.getScript().findImpliedEquality(x, y));
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage());
                       parser.env.printError(getError());
                   }
               }
            :}
          ;
commandPar ::= LPAR command RPAR
             | error;
script ::= commandPar*;

symbol ::= SYMBOL | CONTINUEDEXECUTION | ERRORSYM | FALSE | IMMEDIATEEXIT |
           INCOMPLETE | LOGIC | NONE | MEMOUT | SAT | SUCCESS | THEORY | TRUE |
           UNKNOWN | UNSUPPORTED | UNSAT | INCLUDE | SIMPLIFY |
           TIMED | GETINTERPOLANTS | FINDIMPLIEDEQUALITY | ALLSAT;

/* The following are reserved words and are only allowed in sexpr. */
allsymbol ::= symbol |
         PAR | NUMERALSYM | DECIMALSYM | STRINGSYM |
         UNDERSCORE | AS | BANG | LET | FORALL | EXISTS | MATCH |
         ASSERT | CHECKSAT | CHECKSATASSUMING |
         DECLARESORT | DECLAREFUN | DECLARECONST | DEFINESORT | DEFINEFUN |
         ECHO | EXIT | GETASSERTIONS | GETASSIGNMENT | GETINFO |
         GETMODEL | GETOPTION | GETPROOF | GETUNSATASSUMPTIONS |
         GETUNSATCORE | GETVALUE |
         POP | PUSH | RESET | RESETASSERTIONS |
         SETLOGIC | SETINFO | SETOPTION | DECLAREDATATYPE | DECLAREDATATYPES;

keywordAttr   ::= CPATTERN | CNAMED;
keywordTheory ::= CSORTSDESCRIPTION | CSORTS |
                  CFUNS | CFUNSDESCRIPTION | CDEFINITION;
keywordLogic ::= CEXTENSIONS | CLANGUAGE | CTHEORIES;
keywordTheoryLogic ::= keywordTheory | keywordLogic | CNOTES | CVALUES;
keywordOption ::= CDIAGNOSTICOUTPUTCHANNEL | CREGULAROUTPUTCHANNEL |
         CEXPANDDEFINITIONS | CINTERACTIVEMODE | CPRINTSUCCESS | CVERBOSITY |
         CPRODUCEASSIGNMENTS | CPRODUCEMODELS | CPRODUCEPROOFS | CPRODUCEUNSATCORES |
         CRANDOMSEED | CTIMEOUT | CINTERPOLANTCHECKMODE | CSTRONGSIMPLIFIER;

keywordNoAttr ::= KEYWORD | keywordTheoryLogic | keywordOption;
keywordNoTheory ::= KEYWORD | keywordAttr | keywordLogic | keywordOption;
keywordNoLogic ::= KEYWORD | keywordAttr | keywordTheory | keywordOption;
keywordNoOption ::= KEYWORD | keywordAttr | keywordTheoryLogic;
keyword ::= KEYWORD | keywordAttr | keywordTheoryLogic | keywordOption;
