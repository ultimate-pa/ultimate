(set-option :produce-proofs true)
(set-option :produce-interpolants true)
(set-option :interpolant-check-mode true)

(set-logic QF_AUFLIA)
(declare-fun i () Int)
(declare-fun j () Int)
(declare-fun k1 () Int)
(declare-fun k2 () Int)
(declare-fun k3 () Int)
(declare-fun k4 () Int)
(declare-fun v1 () Int)
(declare-fun v2 () Int)
(declare-fun v3 () Int)
(declare-fun v4 () Int)
(declare-fun y () Int)
(declare-fun x1 () Int)
(declare-fun x2 () Int)
(declare-fun x3 () Int)
(declare-fun x4 () Int)
(declare-fun a () (Array Int Int))
(declare-fun b () (Array Int Int))
(declare-fun s1 () (Array Int Int))
(declare-fun s2 () (Array Int Int))
(declare-fun s3 () (Array Int Int))
(declare-fun s4 () (Array Int Int))

(assert (! (= a s1) :named P0))
(assert (! (and (= s3 (store s2 k2 v2)) (not (= k2 x2))) :named P1))
(assert (! (and (< (select a i) 0) (and (= i y) (and (= i x1) (and (= i x2) 
	(and (= i x3) (= i x4)))))) :named P2))
(assert (! (and (= s3 s4) (and (= s2 (store s1 k1 v1)) (not (= k1 x1)))) :named P3))
(assert (! (and (= y j) (< 0 (select b j))) :named P4))
(assert (! (and (= b (store (store s4 k3 v3) k4 v4))
	(and (not (= k3 x3)) (not (= k4 x4)))) :named P5))
(assert (! (and (not (= v1 v2)) (and (not (= v1 v3)) (and (not (= v1 v4))
	(and (not (= v2 v3)) (and (not (= v2 v4)) (not (= v3 v4))))))) :named P6))

(check-sat)
(set-option :print-terms-cse false)
(get-proof)
(get-interpolants P0 (P1) P2 (P3 (P4) P5) P6)
(exit)