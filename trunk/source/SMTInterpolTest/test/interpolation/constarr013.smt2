(set-option :produce-proofs true)
(set-option :produce-interpolants true)
(set-option :proof-transformation LURPI)
(set-option :simplify-interpolants true)
(set-option :proof-check-mode true)
(set-option :interpolant-check-mode true)

(set-logic QF_AUFLIA)
(declare-fun i1 () Int)
(declare-fun i2 () Int)
(declare-fun i3 () Int)
(declare-fun k21 () Int)
(declare-fun k22 () Int)
(declare-fun k31 () Int)
(declare-fun v () Int)
(declare-fun v1 () Int)
(declare-fun v2 () Int)
(declare-fun v3 () Int)
(declare-fun v21 () Int)
(declare-fun v22 () Int)
(declare-fun v31 () Int)
(declare-fun b () (Array Int Int))
(declare-fun s1 () (Array Int Int))
(declare-fun s2 () (Array Int Int))
(declare-fun s21 () (Array Int Int))
(declare-fun s22 () (Array Int Int))
(declare-fun s31 () (Array Int Int))
(declare-fun s32 () (Array Int Int))

(declare-fun p2 (Int) Bool)
(declare-fun p3 (Int) Bool)

(assert (! (and (= (store ((as const (Array Int Int)) v) i1 v1) s1) (= (store s2 i3 v3) b)
(= v (select b i1)) (= (store ((as const (Array Int Int)) v) k21 v21) s21)
(= (store s22 k22 v22) b) (= v (select s31 i3))
(= (select s32 i3) (select b i3)) (p2 k21) (p2 k22)
(p3 i3) (not (= ((as const (Array Int Int)) v) b))) :named A))
(assert (! (and (= (store s1 i2 v2) s2) (= (select s21 i2) (select s22 i2))
(= (store s31 k31 v31) s32) (not (p2 i2)) (not (p3 k31))) :named B))

(check-sat)
;(set-option :print-terms-cse false)
(get-proof)
(get-interpolants A B)
(exit)
