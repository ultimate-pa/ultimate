(set-option :print-success false)
(set-option :produce-proofs false)
(set-option :interpolant-check-mode false)
(set-logic UF)
(set-info :source |First push block from orr-eeaa-sanitized/csll-is_h_on_cycle.imp.smt2|)
; currently this runs through correctly in a few minutes outside of JUnit, using less than 2GB of memory, JUnit crashes oom at 2GB -- don't know why JUnit makes a difference
(set-info :smt-lib-version 2.0)
(set-info :category "crafted")
(set-info :status unsat)

(declare-sort V 0)
(declare-fun R_km0 (V V) Bool)
(declare-fun null () V)
(declare-fun R_k0 (V V) Bool)
(declare-fun i () V)
(declare-fun z$4 () V)
(declare-fun m (V V) Bool)
(declare-fun z$3 () V)
(declare-fun k* (V V) Bool)
(declare-fun k0 (V) V)
(declare-fun km0 (V) V)
(declare-fun h () V)

(declare-fun EQ (V V) Bool)
(assert (forall ((x V)) (EQ x x)))
(assert (forall ((x V) (y V)) (=> (EQ x y) (EQ y x))))
(assert (forall ((x V) (y V) (z V)) (=> (and (EQ x y) (EQ y z)) (EQ x z))))
(assert (forall ((x0 V) (y0 V) (x1 V) (y1 V)) (=> (and (EQ x0 y0) (EQ x1 y1)) (=> (R_km0 x0 x1) (R_km0 y0 y1)))))
(assert (forall ((x0 V) (y0 V) (x1 V) (y1 V)) (=> (and (EQ x0 y0) (EQ x1 y1)) (=> (R_k0 x0 x1) (R_k0 y0 y1)))))
(assert (forall ((x0 V) (y0 V) (x1 V) (y1 V)) (=> (and (EQ x0 y0) (EQ x1 y1)) (=> (m x0 x1) (m y0 y1)))))
(assert (forall ((x0 V) (y0 V) (x1 V) (y1 V)) (=> (and (EQ x0 y0) (EQ x1 y1)) (=> (k* x0 x1) (k* y0 y1)))))

(assert (forall ((u$1$1 V)) (k* u$1$1 u$1$1)))
(assert (forall ((u$2$1 V) (v$1$1 V) (w$1$1 V)) (=> (and (k* u$2$1 v$1$1) (k* v$1$1 w$1$1)) (k* u$2$1 w$1$1))))
(assert (forall ((u$3$1 V) (v$2$1 V) (w$2$1 V)) (=> (and (k* u$3$1 v$2$1) (k* u$3$1 w$2$1)) (or (k* v$2$1 w$2$1) (k* w$2$1 v$2$1)))))
(assert (forall ((u$4$1 V) (v$3$1 V)) (=> (k* u$4$1 v$3$1) (=> (k* v$3$1 u$4$1) (EQ u$4$1 v$3$1)))))
(assert (forall ((v$4$1 V)) (=> (or (k* null v$4$1) (k* v$4$1 null)) (EQ null v$4$1))))
(assert (forall ((u$5$1 V) (v$5$1 V) (w$3$1 V)) (=> (and (k* u$5$1 v$5$1) (m u$5$1 w$3$1)) (EQ u$5$1 v$5$1))))
(assert (forall ((u$6$1 V) (v$6$1 V) (w$4$1 V)) (=> (and (m u$6$1 v$6$1) (m u$6$1 w$4$1)) (EQ v$6$1 w$4$1))))
(assert (forall ((u$7$1 V) (v$7$1 V)) (=> (m u$7$1 v$7$1) (k* v$7$1 u$7$1))))
(assert (not (m null null)))
(assert (forall ((u$8$1 V) (@b@1$1 V) (@b@2$1 V)) (=> (and (R_km0 u$8$1 @b@2$1) (R_k0 u$8$1 @b@1$1)) (or (and (k* u$8$1 @b@1$1) (m @b@1$1 @b@2$1) (k* @b@2$1 u$8$1)) (and (R_k0 u$8$1 u$8$1) (R_km0 u$8$1 u$8$1) (forall ((v$8$1 V) (w$5$1 V)) (=> (and (k* u$8$1 v$8$1) (m v$8$1 w$5$1)) (not (k* w$5$1 u$8$1)))))))))
(assert (forall ((u$9$1 V) (v$9$1 V) (w$6$1 V)) (=> (and (R_k0 u$9$1 v$9$1) (R_k0 u$9$1 w$6$1)) (EQ v$9$1 w$6$1))))
(assert (forall ((u$10$1 V) (v$10$1 V) (w$7$1 V)) (=> (and (R_km0 u$10$1 v$10$1) (R_km0 u$10$1 w$7$1)) (EQ v$10$1 w$7$1))))
(assert (forall ((u$11$1 V) (v$11$1 V)) (=> (R_k0 u$11$1 v$11$1) (R_k0 v$11$1 v$11$1))))
(assert (forall ((u$12$1 V) (v$12$1 V)) (=> (R_km0 u$12$1 v$12$1) (R_km0 v$12$1 v$12$1))))
(assert (forall ((x$1$1 V) (y$1$1 V) (z$1$1 V)) (=> (and (R_k0 x$1$1 y$1$1) (R_km0 x$1$1 z$1$1)) (R_k0 z$1$1 y$1$1))))
(assert (forall ((x$2$1 V) (y$2$1 V) (z$2$1 V)) (=> (and (R_k0 x$2$1 y$2$1) (R_km0 x$2$1 z$2$1)) (R_km0 y$2$1 z$2$1))))
(assert (or (or (and (k* i z$3) (not (EQ i z$3)) (forall ((w$8$1 V)) (=> (and (k* i w$8$1) (not (EQ i w$8$1))) (k* z$3 w$8$1)))) (m i z$3)) (and (EQ z$3 null) (forall ((w$9$1 V)) (and (not (and (k* i w$9$1) (not (EQ i w$9$1)))) (not (m i w$9$1)))))))

(assert (not (=> (and (exists ((k0_null$1 V)) (R_k0 null k0_null$1)) (exists ((km0_null$1 V)) (R_km0 null km0_null$1)) (exists ((k0_h$1 V)) (R_k0 h k0_h$1)) (exists ((km0_h$1 V)) (R_km0 h km0_h$1)) (exists ((k0_z$3$1 V)) (R_k0 z$3 k0_z$3$1)) (exists ((km0_z$3$1 V)) (R_km0 z$3 km0_z$3$1)) (exists ((k0_i$1 V)) (R_k0 i k0_i$1)) (exists ((km0_i$1 V)) (R_km0 i km0_i$1))) (forall ((@b@1$2 V) (@b@2$2 V)) (=> (and (R_km0 h @b@2$2) (R_k0 h @b@1$2)) (=> (and (not (EQ h null)) (ite (m @b@1$2 @b@2$2) (and (not (EQ i null)) (k* i @b@1$2)) (not (k* i @b@1$2)))) (ite (and (not (EQ i null)) (not (EQ i h))) (and (not (EQ i null)) (not (EQ h null)) (ite (m @b@1$2 @b@2$2) (and (not (EQ z$3 null)) (k* z$3 @b@1$2)) (not (k* z$3 @b@1$2)))) (ite (EQ i h) (m @b@1$2 @b@2$2) (and (EQ i null) (not (m @b@1$2 @b@2$2)))))))))))

(check-sat)

(exit)
